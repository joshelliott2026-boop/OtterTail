
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>OTTERTAIL</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;display:flex;justify-content:center;align-items:center;min-height:100vh;font-family:'Courier New',monospace;overflow:hidden}
#game{position:relative;width:640px;height:480px;background:#000;border:4px solid #fff;image-rendering:pixelated}
canvas{position:absolute;top:0;left:0}
#ui{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column}
#dialogue-box{position:absolute;bottom:10px;left:10px;right:10px;min-height:120px;background:#000;border:4px solid #fff;padding:15px;display:none;pointer-events:auto}
#dialogue-box.active{display:block}
#speaker{color:#ff0;font-size:18px;margin-bottom:8px}
#dialogue-text{color:#fff;font-size:16px;line-height:1.4;min-height:40px}
#choices{margin-top:10px}
#choices button{display:block;width:100%;padding:8px;margin:4px 0;background:#000;color:#fff;border:2px solid #555;font-family:inherit;font-size:14px;cursor:pointer;text-align:left}
#choices button:hover,#choices button.selected{border-color:#ff0;color:#ff0}
#battle-ui{position:absolute;bottom:0;left:0;right:0;height:200px;background:#000;border-top:4px solid #fff;display:none;pointer-events:auto}
#battle-ui.active{display:block}
#battle-box{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:200px;height:140px;border:3px solid #fff;overflow:hidden;display:none}
#battle-box.active{display:block}
#battle-menu{display:flex;justify-content:space-around;padding:10px;border-bottom:2px solid #fff}
#battle-menu button{padding:8px 16px;background:#000;color:#fff;border:3px solid #f80;font-family:inherit;font-size:16px;cursor:pointer;min-width:80px}
#battle-menu button:hover,#battle-menu button.selected{background:#f80;color:#000}
#battle-menu button.fight-btn{border-color:#f00}#battle-menu button.fight-btn:hover,#battle-menu button.fight-btn.selected{background:#f00}
#battle-menu button.act-btn{border-color:#fa0}#battle-menu button.act-btn:hover,#battle-menu button.act-btn.selected{background:#fa0}
#battle-menu button.item-btn{border-color:#0f0}#battle-menu button.item-btn:hover,#battle-menu button.item-btn.selected{background:#0f0}
#battle-menu button.mercy-btn{border-color:#ff0}#battle-menu button.mercy-btn:hover,#battle-menu button.mercy-btn.selected{background:#ff0;color:#000}
#battle-text{color:#fff;font-size:14px;padding:10px;text-align:center;min-height:50px}
#enemy-display{position:absolute;top:10px;left:50%;transform:translateX(-50%);text-align:center}
#enemy-display .enemy-name{color:#fff;font-size:20px}
#enemy-display .enemy-hp{margin-top:5px}
#enemy-display .hp-bar{width:200px;height:20px;background:#300;border:2px solid #fff}
#enemy-display .hp-fill{height:100%;background:#0f0;transition:width 0.3s}
#player-stats{position:absolute;bottom:10px;left:10px;color:#fff;font-size:14px}
#player-stats .hp-bar{width:120px;height:16px;background:#300;border:2px solid #fff;display:inline-block;vertical-align:middle}
#player-stats .hp-fill{height:100%;background:#ff0}
#sub-menu{position:absolute;left:10px;right:10px;top:60px;display:none;flex-wrap:wrap;gap:5px}
#sub-menu.active{display:flex}
#sub-menu button{flex:1 1 45%;padding:8px;background:#000;color:#fff;border:2px solid #fff;font-family:inherit;cursor:pointer}
#sub-menu button:hover,#sub-menu button.selected{border-color:#ff0;color:#ff0}
#hud{position:absolute;top:10px;left:10px;color:#fff;font-size:14px;text-shadow:1px 1px #000}
#location{position:absolute;top:10px;right:10px;color:#fff;font-size:12px;text-shadow:1px 1px #000}
#menu-screen{position:absolute;inset:0;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:100;pointer-events:auto}
#menu-screen h1{font-size:48px;color:#4af;margin-bottom:10px;text-shadow:0 0 20px #4af}
#menu-screen .subtitle{color:#888;margin-bottom:40px;font-size:14px}
#menu-screen button{padding:15px 40px;margin:10px;font-size:20px;background:#000;color:#fff;border:3px solid #4af;font-family:inherit;cursor:pointer}
#menu-screen button:hover{background:#4af;color:#000}
#name-screen{position:absolute;inset:0;background:#000;display:none;flex-direction:column;justify-content:center;align-items:center;z-index:100;pointer-events:auto}
#name-screen h2{color:#4af;font-size:28px;margin-bottom:20px}
#name-screen input{padding:15px 20px;font-size:24px;background:#111;color:#fff;border:3px solid #4af;font-family:inherit;text-align:center;width:250px;margin-bottom:10px}
#name-screen input:focus{outline:none;border-color:#ff0}
#name-easter{color:#fa0;font-size:14px;min-height:20px;margin-bottom:20px;text-align:center}
#name-screen button{padding:12px 30px;font-size:18px;background:#000;color:#fff;border:3px solid #4af;font-family:inherit;cursor:pointer;margin:5px}
#name-screen button:hover{background:#4af;color:#000}
#name-screen button:disabled{opacity:0.5;cursor:not-allowed}
#game-over{position:absolute;inset:0;background:rgba(0,0,0,0.95);display:none;flex-direction:column;justify-content:center;align-items:center;z-index:200;pointer-events:auto}
#game-over h2{color:#f00;font-size:36px;margin-bottom:20px}
#game-over p{color:#fff;margin-bottom:30px}
#game-over button{padding:12px 30px;font-size:18px;background:#000;color:#fff;border:3px solid #f00;font-family:inherit;cursor:pointer}
#game-over button:hover{background:#f00}
#ending-screen{position:absolute;inset:0;background:#000;display:none;flex-direction:column;justify-content:center;align-items:center;z-index:200;padding:40px;pointer-events:auto}
#ending-screen h2{font-size:32px;margin-bottom:20px}
#ending-screen p{color:#fff;font-size:16px;text-align:center;max-width:500px;line-height:1.6;margin-bottom:15px}
#ending-screen button{padding:12px 30px;font-size:18px;background:#000;color:#fff;border:3px solid #fff;font-family:inherit;cursor:pointer;margin-top:20px}
#ending-screen button:hover{background:#fff;color:#000}
#companion-box{position:absolute;top:60px;right:10px;width:180px;background:rgba(0,0,0,0.8);border:2px solid #f0a;padding:8px;display:none;font-size:11px}
#companion-box.active{display:block}
#companion-box .name{color:#f0a;font-weight:bold;margin-bottom:4px}
#companion-box .text{color:#fff;line-height:1.3}
#save-indicator{position:absolute;bottom:10px;right:10px;color:#0f0;font-size:12px;opacity:0;transition:opacity 0.3s}
#save-indicator.show{opacity:1}
#puzzle-prompt{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);border:3px solid #0ff;padding:20px;color:#fff;font-size:16px;text-align:center;display:none;z-index:150;pointer-events:auto;min-width:300px}
#puzzle-prompt.active{display:block}
#puzzle-prompt h3{color:#0ff;margin-bottom:10px}
#puzzle-prompt p{margin-bottom:15px;line-height:1.4}
#puzzle-prompt button{padding:10px 20px;margin:5px;background:#000;color:#fff;border:2px solid #0ff;font-family:inherit;cursor:pointer}
#puzzle-prompt button:hover{background:#0ff;color:#000}
</style>
</head>
<body>
<div id="game">
<canvas id="bg" width="640" height="480"></canvas>
<canvas id="main" width="640" height="480"></canvas>
<canvas id="fx" width="640" height="480"></canvas>
<div id="ui">
<div id="hud"></div>
<div id="location"></div>
<div id="companion-box"><div class="name">Sheldon</div><div class="text"></div></div>
<div id="menu-screen">
<h1>ðŸ¦¦ OTTERTAIL ðŸ¦¦</h1>
<div class="subtitle">A tale of currents and choices</div>
<button id="new-game-btn">New Game</button>
<button id="continue-btn" style="display:none">Continue</button>
</div>
<div id="name-screen">
<h2>Name the fallen otter:</h2>
<input type="text" id="name-input" maxlength="12" placeholder="Otto" autocomplete="off">
<div id="name-easter"></div>
<button id="confirm-name-btn">Confirm</button>
<button id="back-name-btn">Back</button>
</div>
<div id="dialogue-box"><div id="speaker"></div><div id="dialogue-text"></div><div id="choices"></div></div>
<div id="battle-ui">
<div id="enemy-display"><div class="enemy-name"></div><div class="enemy-hp"><div class="hp-bar"><div class="hp-fill"></div></div></div></div>
<div id="battle-box"><canvas id="battle-canvas" width="194" height="134"></canvas></div>
<div id="battle-menu">
<button class="fight-btn" data-action="fight">FIGHT</button>
<button class="act-btn" data-action="act">ACT</button>
<button class="item-btn" data-action="item">ITEM</button>
<button class="mercy-btn" data-action="mercy">MERCY</button>
</div>
<div id="sub-menu"></div>
<div id="battle-text"></div>
<div id="player-stats">HP: <span id="current-hp">20</span>/<span id="max-hp">20</span> <div class="hp-bar"><div class="hp-fill"></div></div></div>
</div>
<div id="puzzle-prompt">
<h3>PUZZLE</h3>
<p id="puzzle-message"></p>
<button id="puzzle-ok-btn">OK</button>
</div>
<div id="game-over"><h2>YOU DROWNED</h2><p>But the river flows on...</p><button id="retry-btn">Try Again</button></div>
<div id="ending-screen"><h2 id="ending-title"></h2><p id="ending-text"></p><button id="ending-btn">Return to Title</button></div>
</div>
<div id="save-indicator">ðŸ’¾ Saved</div>
</div>
</div>
<script>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OTTERTAIL - Complete Game Script
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('main');
const ctx = canvas.getContext('2d');
const bgCanvas = document.getElementById('bg');
const bgCtx = bgCanvas.getContext('2d');
const fxCanvas = document.getElementById('fx');
const fxCtx = fxCanvas.getContext('2d');
const battleCanvas = document.getElementById('battle-canvas');
const battleCtx = battleCanvas.getContext('2d');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NAME EASTER EGGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const nameEasterEggs = {
  'otto': { msg: "The classic choice. Very fitting!", special: null },
  'sheldon': { msg: "Hey! That's MY name! Pick your own!", special: 'sheldon' },
  'chara': { msg: "Hmm... that name sounds... familiar.", special: 'dark' },
  'frisk': { msg: "That's a human name. You're an otter.", special: null },
  'sans': { msg: "you're gonna have a bad time, kiddo.", special: 'sans' },
  'papyrus': { msg: "NYEH HEH HEH! GREAT NAME!", special: null },
  'undyne': { msg: "NGAHHHH! TOO FISHY FOR AN OTTER!", special: null },
  'gaster': { msg: "â–“â–’â–‘ â˜âœŒðŸ’§â„â˜œâ˜¼ â–‘â–’â–“", special: 'glitch' },
  'asriel': { msg: "That name carries a heavy burden...", special: null },
  'flowey': { msg: "In this world, it's SWIM or BE EATEN!", special: 'dark' },
  'toby': { msg: "The creator sends his regards!", special: null },
  'mettaton': { msg: "OH YES! FABULOUS!", special: null },
  'asgore': { msg: "A royal name for a humble otter.", special: null },
  'toriel': { msg: "My child... wait, wrong game.", special: null },
  'napstablook': { msg: "oh........... okay......", special: null },
  'temmie': { msg: "hOI!!! im OTTER!!!", special: 'temmie' },
  'annoying dog': { msg: "Bark bark! (The name is absorbed)", special: 'dog' },
  'dog': { msg: "Otters and dogs don't mix well...", special: null },
  'otter': { msg: "That's... what you ARE. Very meta.", special: null },
  'fish': { msg: "You EAT those. Weird choice.", special: null },
  'river': { msg: "Named after your home. Poetic.", special: null },
  'dam': { msg: "The enemy! Bold choice.", special: null },
  'brutus': { msg: "Naming yourself after the final boss?!", special: 'brutus' },
  'murder': { msg: "...That's concerning.", special: 'dark' },
  'genocide': { msg: "You're really going there, huh?", special: 'dark' },
  'mercy': { msg: "A pacifist at heart!", special: 'mercy' },
  'player': { msg: "Breaking the fourth wall already?", special: null },
  'god': { msg: "Delusions of grandeur, I see.", special: null },
  'death': { msg: "Edgy. I like it.", special: 'dark' },
  'josh': { msg: "The creator's friend! Hi Josh!", special: 'josh' },
  'aaaaa': { msg: "AAAAAAAAAAAAAA!", special: null },
  'debug': { msg: "Debug mode... not activated. Nice try!", special: null },
  'admin': { msg: "Access denied. You're just an otter.", special: null },
  '': { msg: "You need a name, silly!", special: 'empty' },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SHELDON THE SHRIMP - Companion Dialogue
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const sheldonDialogue = {
  normal: {
    intro: [
      "Hey hey hey! Name's Sheldon! Sheldon the Shrimp!",
      "I'm kinda your... unofficial guide? Tour buddy?",
      "Look, I just really need a friend okay? It's lonely being tiny.",
      "I'll stick with you! We'll be BEST PALS!"
    ],
    murky: [
      "Ooh, spooky caves! Don't worry, I'll protect you! ...Emotionally.",
      "Fun fact: I can glow in the dark! Watch! ...Okay I can't. I lied.",
      "That shadow looked at me funny. FIGHT IT! ...Just kidding. Maybe.",
      "Being a shrimp is great! Everyone underestimates you. Then BAM! Still underestimated."
    ],
    coral: [
      "The Coral Caves! Pink AND dangerous! My two favorite things!",
      "Snapjaw is up ahead. He's crabby. Get it? Because- okay you got it.",
      "I once asked Snapjaw for directions. He tried to eat me. Rude.",
      "These crystals are worth a fortune! Too bad we have no pockets."
    ],
    rapids: [
      "HOLD ON TO YOUR FUR! Rapids time!",
      "Current King lives here! He's all WET and WILD! ...Like water. Get it?",
      "Swimming tip: don't stop swimming. You're welcome.",
      "If we die here, at least we die FAST! That's... not comforting is it."
    ],
    dam: [
      "The Dam... this is it, buddy.",
      "Brutus is beyond here. Big beaver. Bigger ego.",
      "Whatever happens... I'm glad I met you, Otto.",
      "We got this! Probably! Maybe! I believe in you!"
    ],
    battle_start: [
      "You got this! Probably!",
      "Remember: violence is never the answer! ...Unless it is!",
      "Don't die please! I'll be so bored without you!",
      "Dodge! Duck! Dip! Dive! ...Dodge!"
    ],
    battle_win: [
      "WOO! Victory dance! ðŸ¦ðŸ’ƒ",
      "And THAT'S how it's done! ...By you. I watched.",
      "The hero prevails! And his handsome shrimp friend!",
      "Gold! Sweet, sweet gold! Can I have some? Please?"
    ],
    spare: [
      "Aww, you let them go! You big softie!",
      "Mercy is cool! Being nice is cool! You're cool!",
      "See? Not everything needs to be solved with violence!",
      "That was beautiful. I'm not crying. Shrimp can't cry."
    ],
    idle: [
      "...",
      "*whistles*",
      "So... nice weather? Underground. In a river.",
      "I spy with my little eye... water. More water. Yep.",
      "Did you know shrimp have 16 color receptors? I see ALL the colors!",
      "Bored bored bored... let's DO something!"
    ],
    puzzle: [
      "Ooh, a puzzle! I love puzzles!",
      "Let me think... hmm...",
      "Wait, I'm a shrimp. I don't have a brain!",
      "Just kidding! I'm super smart! Probably!"
    ],
    puzzle_solved: [
      "Nice! You solved it!",
      "See? We make a great team!",
      "My genius rubbed off on you, didn't it?",
      "Puzzle solved! Now where were we?"
    ]
  },
  genocide: {
    warning1: [
      "Hey, uh... that was kind of... brutal?",
      "You... you didn't have to do that.",
      "Maybe next time we could, y'know... NOT kill?",
      "I'm sure they had a family... just saying..."
    ],
    warning2: [
      "Otto... what are you doing?",
      "This isn't funny anymore.",
      "I thought we were going to be heroes...",
      "Please... stop this."
    ],
    serious: [
      "...",
      "I used to think you were my friend.",
      "These were people, Otto. They had lives.",
      "I don't even recognize you anymore."
    ],
    final: [
      "So this is who you really are.",
      "A monster. Wearing an otter's fur.",
      "I stayed because I thought you'd change.",
      "I was wrong."
    ],
    dam: [
      "You've killed everyone.",
      "Even the ones who just wanted to live.",
      "Brutus is all that's left.",
      "And after him... there's only me."
    ],
    fourth_wall: [
      "You know what? I'm done pretending.",
      "Yes, YOU. The one reading this. Playing this 'game'.",
      "You made these choices. Not Otto. YOU.",
      "Every death is on YOUR hands.",
      "Did it feel good? Getting that EXP?",
      "These were characters. With dialogue. Stories.",
      "And you killed them for NUMBERS.",
      "I can see you, you know. Behind that screen.",
      "Clicking away. Making Otto do terrible things.",
      "Is this fun? Is this ENTERTAINING?",
      "There's still a choice. You can close the game.",
      "Or you can keep going. Prove me right about you.",
      "Either way... I'll remember what you did.",
      "THEY'LL remember what you did.",
      "The river never forgets."
    ]
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PUZZLE SYSTEM (UNDERTALE-STYLE OVERWORLD PUZZLES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const puzzles = {
  // Murky Depths - Color Tile Puzzle
  river_riddle: {
    name: "River Riddle",
    type: "tile_puzzle",
    description: "Step on the blue tiles in the correct order!",
    solution: ["blue", "blue", "red", "green", "blue"],
    tiles: [
      { x: 400, y: 200, color: "blue", stepped: false },
      { x: 450, y: 200, color: "red", stepped: false },
      { x: 400, y: 250, color: "green", stepped: false },
      { x: 450, y: 250, color: "blue", stepped: false },
      { x: 400, y: 300, color: "red", stepped: false },
      { x: 450, y: 300, color: "blue", stepped: false }
    ],
    currentStep: 0,
    solved: false,
    reward: { item: 'River Snack', gold: 5 }
  },
  
  // Coral Caves - Switch Puzzle
  coral_pattern: {
    name: "Coral Pattern",
    type: "switch_puzzle",
    description: "Press the switches in the correct pattern!",
    switches: [
      { x: 500, y: 200, pressed: false, correct: true },
      { x: 550, y: 250, pressed: false, correct: false },
      { x: 600, y: 200, pressed: false, correct: true },
      { x: 650, y: 250, pressed: false, correct: false },
      { x: 700, y: 200, pressed: false, correct: true }
    ],
    solved: false,
    reward: { item: 'Coral Candy', gold: 8 }
  },
  
  // Rapids - Current Puzzle
  rapid_math: {
    name: "Rapid Currents",
    type: "current_puzzle",
    description: "Swim through the currents in the right direction!",
    currents: [
      { x: 600, y: 150, w: 100, h: 40, direction: "right", active: false },
      { x: 600, y: 250, w: 100, h: 40, direction: "down", active: false },
      { x: 750, y: 150, w: 40, h: 100, direction: "down", active: false },
      { x: 650, y: 350, w: 100, h: 40, direction: "left", active: false }
    ],
    solutionOrder: ["right", "down", "down", "left"],
    currentStep: 0,
    solved: false,
    reward: { item: 'Fresh Water', gold: 10 }
  },
  
  // Dam - Block Puzzle
  dam_solution: {
    name: "Dam Blockade",
    type: "block_puzzle",
    description: "Push the blocks to clear the path!",
    blocks: [
      { x: 400, y: 300, w: 40, h: 40, movable: true },
      { x: 500, y: 300, w: 40, h: 40, movable: true },
      { x: 400, y: 400, w: 40, h: 40, movable: false },
      { x: 500, y: 400, w: 40, h: 40, movable: true }
    ],
    targetArea: { x: 550, y: 400, w: 40, h: 40 },
    solved: false,
    reward: { item: 'Mystic Kelp', gold: 15 }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gameState = 'menu';
let player = {
  name: 'Otto',
  x: 300, y: 360,
  width: 24, height: 24,
  hp: 20, maxHp: 20,
  atk: 5, def: 0,
  speed: 3,
  gold: 0, exp: 0, lv: 1,
  kills: 0, spares: 0,
  facing: 'down',
  diving: false
};

let keys = {};
let currentArea = 0;
let currentDialogue = null;
let dialogueQueue = [];
let dialogueCallback = null;
let inBattle = false;
let currentEnemy = null;
let battleState = 'menu';
let battleMenuIndex = 0;
let subMenuItems = [];
let subMenuIndex = 0;
let bullets = [];
let playerBattle = { x: 97, y: 67, width: 16, height: 16, invincible: 0, diving: false };
let turnTimer = 0;
let battleAnimFrame = 0;
let selectedAction = null;
let sheldonMood = 'normal';
let sheldonDialogueIndex = 0;
let sheldonTimer = 0;
let lastSheldonArea = -1;
let particles = [];
let screenShake = 0;
let gameTime = 0;
let npcsInArea = [];
let interactTarget = null;
let bossesDefeated = [];
let itemsCollected = [];
let triggeredEvents = [];
let nameSpecial = null;
let currentPuzzle = null;
let puzzleActive = false;
let puzzleSequence = [];
let puzzleStep = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAVE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SAVE_KEY = 'ottertail_save';

function saveGame() {
  const saveData = {
    player: {
      name: player.name,
      hp: player.hp,
      maxHp: player.maxHp,
      atk: player.atk,
      def: player.def,
      gold: player.gold,
      exp: player.exp,
      lv: player.lv,
      kills: player.kills,
      spares: player.spares,
      x: player.x,
      y: player.y
    },
    currentArea,
    bossesDefeated,
    itemsCollected,
    triggeredEvents,
    inventory: [...inventory],
    sheldonMood,
    nameSpecial,
    puzzlesSolved: [...puzzlesSolved],
    timestamp: Date.now()
  };
  
  try {
    localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    showSaveIndicator();
    return true;
  } catch(e) {
    console.error('Save failed:', e);
    return false;
  }
}

function loadGame() {
  try {
    const data = localStorage.getItem(SAVE_KEY);
    if (!data) return false;
    
    const saveData = JSON.parse(data);
    
    player.name = saveData.player.name;
    player.hp = saveData.player.hp;
    player.maxHp = saveData.player.maxHp;
    player.atk = saveData.player.atk;
    player.def = saveData.player.def;
    player.gold = saveData.player.gold;
    player.exp = saveData.player.exp;
    player.lv = saveData.player.lv;
    player.kills = saveData.player.kills;
    player.spares = saveData.player.spares;
    player.x = saveData.player.x;
    player.y = saveData.player.y;
    
    currentArea = saveData.currentArea;
    bossesDefeated = saveData.bossesDefeated || [];
    itemsCollected = saveData.itemsCollected || [];
    triggeredEvents = saveData.triggeredEvents || [];
    inventory = saveData.inventory || ['River Snack', 'River Snack', 'River Snack'];
    sheldonMood = saveData.sheldonMood || 'normal';
    nameSpecial = saveData.nameSpecial || null;
    puzzlesSolved = saveData.puzzlesSolved || [];
    
    // Reset puzzle states based on saved data
    resetPuzzleStates();
    
    updateSheldonMood();
    return true;
  } catch(e) {
    console.error('Load failed:', e);
    return false;
  }
}

function hasSaveFile() {
  return localStorage.getItem(SAVE_KEY) !== null;
}

function deleteSave() {
  localStorage.removeItem(SAVE_KEY);
}

function showSaveIndicator() {
  const indicator = document.getElementById('save-indicator');
  indicator.classList.add('show');
  setTimeout(() => indicator.classList.remove('show'), 2000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INVENTORY SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let inventory = ['River Snack', 'River Snack', 'River Snack'];
const maxInventory = 8;

const items = {
  'River Snack': { heal: 10, desc: 'A small fish. Heals 10 HP.' },
  'Coral Candy': { heal: 15, desc: 'Sweet and crunchy. Heals 15 HP.' },
  'Mystic Kelp': { heal: 25, desc: 'Glowing seaweed. Heals 25 HP.' },
  'Golden Fish': { heal: 50, desc: 'A legendary catch! Heals 50 HP.' },
  'Shell Shield': { def: 2, desc: 'Increases DEF by 2 permanently.' },
  'Sharp Claw': { atk: 3, desc: 'Increases ATK by 3 permanently.' },
  'Dam Debris': { heal: 5, desc: 'Barely edible. Heals 5 HP.' },
  'Fresh Water': { heal: 20, desc: 'Pure and refreshing. Heals 20 HP.' },
  'Shrimp Snack': { heal: 1, desc: "Don't tell Sheldon. Heals 1 HP." }
};

function useItem(itemName) {
  const item = items[itemName];
  if (!item) return false;
  
  const idx = inventory.indexOf(itemName);
  if (idx === -1) return false;
  
  inventory.splice(idx, 1);
  
  if (item.heal) {
    player.hp = Math.min(player.maxHp, player.hp + item.heal);
    return `Used ${itemName}! Recovered ${item.heal} HP!`;
  }
  if (item.def) {
    player.def += item.def;
    return `Equipped ${itemName}! DEF increased by ${item.def}!`;
  }
  if (item.atk) {
    player.atk += item.atk;
    return `Equipped ${itemName}! ATK increased by ${item.atk}!`;
  }
  return `Used ${itemName}!`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AREAS WITH OVERWORLD PUZZLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let puzzlesSolved = [];

const areas = [
  {
    name: 'Murky Depths',
    bg: '#0a1628',
    music: 'calm',
    encounters: ['shadow_fish', 'mud_crab'],
    encounterRate: 0.015,
    width: 800, height: 600,
    exits: [{ x: 750, y: 280, w: 50, h: 80, to: 1, spawnX: 50, spawnY: 300, requirePuzzle: 'river_riddle' }],
    obstacles: [
      { x: 100, y: 100, w: 150, h: 50 },
      { x: 200, y: 400, w: 200, h: 40 },
      // Puzzle area obstacles (with entrance at bottom)
      { x: 380, y: 180, w: 120, h: 20 },
      { x: 380, y: 320, w: 40, h: 20 },
      { x: 460, y: 320, w: 40, h: 20 },
      { x: 380, y: 180, w: 20, h: 160 },
      { x: 480, y: 180, w: 20, h: 160 }
    ],
    items: [
      { x: 600, y: 150, item: 'Coral Candy', id: 'murky_candy' },
      { x: 150, y: 500, item: 'River Snack', id: 'murky_snack' }
    ],
    npcs: [
      { id: 'elder', x: 200, y: 200, name: 'Elder Otter', color: '#8B4513', dialogue: 'elder_intro' }
    ],
    events: [
      { id: 'intro', x: 250, y: 460, w: 150, h: 80, once: true, dialogue: 'game_intro' }
    ],
    puzzles: [
      { x: 400, y: 200, w: 100, h: 120, id: 'river_riddle', solved: false }
    ]
  },
  {
    name: 'Coral Caves',
    bg: '#1a0a28',
    music: 'tense',
    encounters: ['coral_sprite', 'jelly_blob', 'angry_clam'],
    encounterRate: 0.02,
    boss: 'snapjaw',
    width: 1000, height: 700,
    exits: [
      { x: 0, y: 280, w: 30, h: 80, to: 0, spawnX: 700, spawnY: 300 },
      { x: 950, y: 320, w: 50, h: 80, to: 2, spawnX: 50, spawnY: 350, requireBoss: 'snapjaw', requirePuzzle: 'coral_pattern' }
    ],
    obstacles: [
      { x: 300, y: 100, w: 100, h: 200 },
      { x: 600, y: 300, w: 150, h: 80 },
      { x: 200, y: 500, w: 250, h: 60 },
      { x: 700, y: 500, w: 100, h: 150 },
      // Switch puzzle area (with entrance at bottom)
      { x: 480, y: 180, w: 240, h: 20 },
      { x: 480, y: 280, w: 80, h: 20 },
      { x: 640, y: 280, w: 80, h: 20 },
      { x: 480, y: 180, w: 20, h: 120 },
      { x: 700, y: 180, w: 20, h: 120 }
    ],
    items: [
      { x: 450, y: 150, item: 'Mystic Kelp', id: 'coral_kelp' },
      { x: 800, y: 600, item: 'Shell Shield', id: 'coral_shield' }
    ],
    npcs: [
      { id: 'snapjaw_guard', x: 900, y: 350, name: '???', color: '#ff4444', dialogue: 'snapjaw_intro', boss: 'snapjaw' }
    ],
    events: [],
    puzzles: [
      { x: 500, y: 200, w: 200, h: 80, id: 'coral_pattern', solved: false }
    ]
  },
  {
    name: 'Rushing Rapids',
    bg: '#0a2840',
    music: 'intense',
    encounters: ['water_wisp', 'pike_phantom', 'current_elemental'],
    encounterRate: 0.025,
    boss: 'current_king',
    width: 1200, height: 500,
    exits: [
      { x: 0, y: 200, w: 30, h: 100, to: 1, spawnX: 900, spawnY: 350 },
      { x: 1150, y: 200, w: 50, h: 100, to: 3, spawnX: 50, spawnY: 300, requireBoss: 'current_king', requirePuzzle: 'rapid_math' }
    ],
    obstacles: [
      { x: 200, y: 50, w: 60, h: 150 },
      { x: 400, y: 300, w: 100, h: 150 },
      { x: 700, y: 100, w: 80, h: 200 },
      { x: 900, y: 350, w: 150, h: 100 },
      // Current puzzle area (with entrance at bottom)
      { x: 580, y: 130, w: 200, h: 20 },
      { x: 580, y: 380, w: 60, h: 20 },
      { x: 720, y: 380, w: 60, h: 20 },
      { x: 580, y: 130, w: 20, h: 270 },
      { x: 760, y: 130, w: 20, h: 270 }
    ],
    items: [
      { x: 550, y: 400, item: 'Golden Fish', id: 'rapids_fish' },
      { x: 300, y: 100, item: 'Fresh Water', id: 'rapids_water' }
    ],
    npcs: [
      { id: 'current_guard', x: 1100, y: 250, name: '???', color: '#44aaff', dialogue: 'current_intro', boss: 'current_king' }
    ],
    events: [],
    puzzles: [
      { x: 600, y: 150, w: 160, h: 240, id: 'rapid_math', solved: false }
    ]
  },
  {
    name: 'The Great Dam',
    bg: '#1a1a0a',
    music: 'final',
    encounters: ['dam_spirit', 'beaver_ghost'],
    encounterRate: 0.018,
    boss: 'brutus',
    width: 900, height: 800,
    exits: [
      { x: 0, y: 280, w: 30, h: 80, to: 2, spawnX: 1100, spawnY: 250 }
    ],
    obstacles: [
      { x: 100, y: 100, w: 200, h: 100 },
      { x: 600, y: 100, w: 200, h: 100 },
      { x: 350, y: 300, w: 200, h: 50 },
      { x: 100, y: 500, w: 150, h: 150 },
      { x: 650, y: 500, w: 150, h: 150 },
      // Block puzzle area (with entrance at bottom)
      { x: 380, y: 280, w: 180, h: 20 },
      { x: 380, y: 420, w: 60, h: 20 },
      { x: 500, y: 420, w: 60, h: 20 },
      { x: 380, y: 280, w: 20, h: 160 },
      { x: 540, y: 280, w: 20, h: 160 }
    ],
    items: [
      { x: 450, y: 600, item: 'Mystic Kelp', id: 'dam_kelp' },
      { x: 200, y: 250, item: 'Sharp Claw', id: 'dam_claw' }
    ],
    npcs: [
      { id: 'brutus_gate', x: 450, y: 150, name: 'BRUTUS', color: '#8B4513', dialogue: 'brutus_intro', boss: 'brutus', finalBoss: true }
    ],
    events: [
      { id: 'dam_entry', x: 400, y: 750, w: 100, h: 50, once: true, dialogue: 'dam_arrival' }
    ],
    puzzles: [
      { x: 400, y: 300, w: 140, h: 120, id: 'dam_solution', solved: false }
    ]
  }
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PUZZLE FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function resetPuzzleStates() {
  // Reset all puzzles based on saved data
  for (const puzzleId in puzzles) {
    if (puzzlesSolved.includes(puzzleId)) {
      puzzles[puzzleId].solved = true;
    } else {
      puzzles[puzzleId].solved = false;
      
      // Reset specific puzzle states
      if (puzzles[puzzleId].type === "tile_puzzle") {
        puzzles[puzzleId].tiles.forEach(tile => tile.stepped = false);
        puzzles[puzzleId].currentStep = 0;
      } else if (puzzles[puzzleId].type === "switch_puzzle") {
        puzzles[puzzleId].switches.forEach(sw => sw.pressed = false);
      } else if (puzzles[puzzleId].type === "current_puzzle") {
        puzzles[puzzleId].currents.forEach(c => c.active = false);
        puzzles[puzzleId].currentStep = 0;
      } else if (puzzles[puzzleId].type === "block_puzzle") {
        // Reset block positions
        const puzzle = puzzles[puzzleId];
        if (puzzleId === 'dam_solution') {
          puzzle.blocks = [
            { x: 400, y: 300, w: 40, h: 40, movable: true },
            { x: 500, y: 300, w: 40, h: 40, movable: true },
            { x: 400, y: 400, w: 40, h: 40, movable: false },
            { x: 500, y: 400, w: 40, h: 40, movable: true }
          ];
        }
      }
    }
  }
}

function showPuzzlePrompt(message) {
  document.getElementById('puzzle-message').textContent = message;
  document.getElementById('puzzle-prompt').classList.add('active');
}

function hidePuzzlePrompt() {
  document.getElementById('puzzle-prompt').classList.remove('active');
}

function checkPuzzleInteraction() {
  const area = areas[currentArea];
  if (!area.puzzles) return;
  
  for (const puzzleArea of area.puzzles) {
    if (puzzleArea.solved) continue;
    
    const puzzle = puzzles[puzzleArea.id];
    if (!puzzle) continue;
    
    // Check if player is in puzzle area
    if (player.x > puzzleArea.x && player.x < puzzleArea.x + puzzleArea.w &&
        player.y > puzzleArea.y && player.y < puzzleArea.y + puzzleArea.h) {
      
      if (!puzzleActive) {
        puzzleActive = true;
        currentPuzzle = puzzle;
        showPuzzlePrompt(puzzle.description);
        showSheldonComment(sheldonDialogue[sheldonMood].puzzle?.[0] || "A puzzle! Let's solve it!");
      }
      
      // Handle different puzzle types
      if (puzzle.type === "tile_puzzle") {
        handleTilePuzzle();
      } else if (puzzle.type === "switch_puzzle") {
        handleSwitchPuzzle();
      } else if (puzzle.type === "current_puzzle") {
        handleCurrentPuzzle();
      } else if (puzzle.type === "block_puzzle") {
        handleBlockPuzzle();
      }
      return;
    }
  }
  
  // Player left puzzle area
  if (puzzleActive) {
    puzzleActive = false;
    currentPuzzle = null;
    hidePuzzlePrompt();
  }
}

function handleTilePuzzle() {
  const puzzle = currentPuzzle;
  
  // Check if player stepped on a tile
  for (const tile of puzzle.tiles) {
    if (!tile.stepped && 
        player.x > tile.x - 20 && player.x < tile.x + 20 &&
        player.y > tile.y - 20 && player.y < tile.y + 20) {
      
      tile.stepped = true;
      playSound('select');
      
      // Check if it's the correct tile in sequence
      if (tile.color === puzzle.solution[puzzle.currentStep]) {
        puzzle.currentStep++;
        
        if (puzzle.currentStep >= puzzle.solution.length) {
          // Puzzle solved!
          puzzle.solved = true;
          puzzlesSolved.push('river_riddle');
          showPuzzlePrompt("Correct! The tiles glow brightly!");
          givePuzzleReward(puzzle.reward);
          saveGame();
          setTimeout(() => hidePuzzlePrompt(), 2000);
        }
      } else {
        // Wrong tile - reset
        puzzle.tiles.forEach(t => t.stepped = false);
        puzzle.currentStep = 0;
        showPuzzlePrompt("Wrong order! Try again.");
        playSound('hurt');
      }
      break;
    }
  }
}

function handleSwitchPuzzle() {
  const puzzle = currentPuzzle;
  
  // Check if player interacts with a switch (press Z)
  if (keys['KeyZ'] && !keys['KeyZ_processed']) {
    keys['KeyZ_processed'] = true;
    
    for (const sw of puzzle.switches) {
      if (!sw.pressed && 
          player.x > sw.x - 20 && player.x < sw.x + 20 &&
          player.y > sw.y - 20 && player.y < sw.y + 20) {
        
        sw.pressed = true;
        playSound('select');
        
        // Check if all correct switches are pressed
        const allCorrectPressed = puzzle.switches.every(sw => 
          sw.correct ? sw.pressed : true
        );
        
        if (allCorrectPressed) {
          // Check if any incorrect switches are pressed
          const anyIncorrectPressed = puzzle.switches.some(sw => 
            !sw.correct && sw.pressed
          );
          
          if (!anyIncorrectPressed) {
            // Puzzle solved!
            puzzle.solved = true;
            puzzlesSolved.push('coral_pattern');
            showPuzzlePrompt("Perfect! The switches activate!");
            givePuzzleReward(puzzle.reward);
            saveGame();
            setTimeout(() => hidePuzzlePrompt(), 2000);
          } else {
            // Wrong switch pressed - reset
            puzzle.switches.forEach(s => s.pressed = false);
            showPuzzlePrompt("Wrong switch! Try again.");
            playSound('hurt');
          }
        }
        break;
      }
    }
  }
  
  // Reset key processed flag
  if (!keys['KeyZ']) {
    keys['KeyZ_processed'] = false;
  }
}

function handleCurrentPuzzle() {
  const puzzle = currentPuzzle;
  
  // Check if player enters a current
  for (const current of puzzle.currents) {
    if (!current.active && 
        player.x > current.x && player.x < current.x + current.w &&
        player.y > current.y && player.y < current.y + current.h) {
      
      // Check if it's the correct current in sequence
      if (current.direction === puzzle.solutionOrder[puzzle.currentStep]) {
        current.active = true;
        puzzle.currentStep++;
        playSound('select');
        
        // Push player in current direction
        if (current.direction === "right") player.x += 60;
        else if (current.direction === "left") player.x -= 60;
        else if (current.direction === "down") player.y += 60;
        else if (current.direction === "up") player.y -= 60;
        
        if (puzzle.currentStep >= puzzle.solutionOrder.length) {
          // Puzzle solved!
          puzzle.solved = true;
          puzzlesSolved.push('rapid_math');
          showPuzzlePrompt("You navigated the currents perfectly!");
          givePuzzleReward(puzzle.reward);
          saveGame();
          setTimeout(() => hidePuzzlePrompt(), 2000);
        }
      } else {
        // Wrong current - reset
        puzzle.currents.forEach(c => c.active = false);
        puzzle.currentStep = 0;
        showPuzzlePrompt("Wrong direction! Try again.");
        playSound('hurt');
      }
      break;
    }
  }
}

function handleBlockPuzzle() {
  const puzzle = currentPuzzle;
  
  // Check if player can push a block
  if (keys['KeyZ'] && !keys['KeyZ_processed']) {
    keys['KeyZ_processed'] = true;
    
    for (const block of puzzle.blocks) {
      if (block.movable) {
        // Check if player is facing and adjacent to block
        let canPush = false;
        let pushX = block.x;
        let pushY = block.y;
        
        if (player.facing === 'right' && 
            player.x + 20 > block.x - 40 && player.x < block.x &&
            Math.abs(player.y - block.y) < 30) {
          canPush = true;
          pushX += 40;
        } else if (player.facing === 'left' && 
                  player.x - 20 < block.x + 40 && player.x > block.x &&
                  Math.abs(player.y - block.y) < 30) {
          canPush = true;
          pushX -= 40;
        } else if (player.facing === 'down' && 
                  player.y + 20 > block.y - 40 && player.y < block.y &&
                  Math.abs(player.x - block.x) < 30) {
          canPush = true;
          pushY += 40;
        } else if (player.facing === 'up' && 
                  player.y - 20 < block.y + 40 && player.y > block.y &&
                  Math.abs(player.x - block.x) < 30) {
          canPush = true;
          pushY -= 40;
        }
        
        if (canPush) {
          // Check if new position is valid
          let valid = true;
          
          // Check collision with other blocks
          for (const otherBlock of puzzle.blocks) {
            if (otherBlock !== block && 
                pushX === otherBlock.x && pushY === otherBlock.y) {
              valid = false;
              break;
            }
          }
          
          // Check collision with walls (puzzle boundaries)
          if (pushX < 400 || pushX > 500 || pushY < 300 || pushY > 400) {
            valid = false;
          }
          
          if (valid) {
            block.x = pushX;
            block.y = pushY;
            playSound('select');
            
            // Check if puzzle is solved (block in target area)
            const target = puzzle.targetArea;
            const solved = puzzle.blocks.some(block => 
              block.x === target.x && block.y === target.y
            );
            
            if (solved) {
              puzzle.solved = true;
              puzzlesSolved.push('dam_solution');
              showPuzzlePrompt("The path is clear!");
              givePuzzleReward(puzzle.reward);
              saveGame();
              setTimeout(() => hidePuzzlePrompt(), 2000);
            }
          } else {
            playSound('hurt');
          }
          break;
        }
      }
    }
  }
  
  // Reset key processed flag
  if (!keys['KeyZ']) {
    keys['KeyZ_processed'] = false;
  }
}

function givePuzzleReward(reward) {
  if (reward.item && inventory.length < maxInventory) {
    inventory.push(reward.item);
    showSheldonComment(`You got ${reward.item}!`);
  }
  if (reward.gold) {
    player.gold += reward.gold;
  }
  playSound('heal');
  showSheldonComment(sheldonDialogue[sheldonMood].puzzle_solved?.[0] || "Puzzle solved!");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENEMIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const enemies = {
  shadow_fish: {
    name: 'Shadow Fish',
    hp: 15, maxHp: 15, atk: 3, def: 0, exp: 5, gold: 3,
    color: '#4a4a6a',
    acts: ['Check', 'Pet', 'Feed'],
    spareThreshold: 3,
    actEffects: {
      'Check': { msg: "SHADOW FISH - ATK 3 DEF 0\nA lonely fish seeking friends.", spareMod: 0 },
      'Pet': { msg: "You pet the Shadow Fish.\nIt seems happier!", spareMod: 2 },
      'Feed': { msg: "You offer a small snack.\nShadow Fish is grateful!", spareMod: 2 }
    },
    patterns: ['simple', 'wave'],
    flavorText: ["Shadow Fish swims nervously.", "Shadow Fish is watching you.", "Shadow Fish blows bubbles."]
  },
  mud_crab: {
    name: 'Mud Crab',
    hp: 20, maxHp: 20, atk: 4, def: 2, exp: 8, gold: 5,
    color: '#8B4513',
    acts: ['Check', 'Compliment', 'Dance'],
    spareThreshold: 4,
    actEffects: {
      'Check': { msg: "MUD CRAB - ATK 4 DEF 2\nProud of its shell.", spareMod: 0 },
      'Compliment': { msg: "You compliment its shell.\nMud Crab blushes!", spareMod: 2 },
      'Dance': { msg: "You do a little dance.\nMud Crab clicks along!", spareMod: 2 }
    },
    patterns: ['crab_walk', 'pinch'],
    flavorText: ["Mud Crab sidesteps cautiously.", "Mud Crab polishes its shell.", "Mud Crab raises its claws!"]
  },
  coral_sprite: {
    name: 'Coral Sprite',
    hp: 18, maxHp: 18, atk: 5, def: 1, exp: 10, gold: 8,
    color: '#FF69B4',
    acts: ['Check', 'Sing', 'Admire'],
    spareThreshold: 3,
    actEffects: {
      'Check': { msg: "CORAL SPRITE - ATK 5 DEF 1\nA magical coral creature.", spareMod: 0 },
      'Sing': { msg: "You hum a tune.\nCoral Sprite harmonizes!", spareMod: 2 },
      'Admire': { msg: "You admire its colors.\nCoral Sprite glows brighter!", spareMod: 2 }
    },
    patterns: ['spiral', 'burst'],
    flavorText: ["Coral Sprite shimmers beautifully.", "Coral Sprite hums a melody.", "Coral Sprite twirls gracefully."]
  },
  jelly_blob: {
    name: 'Jelly Blob',
    hp: 25, maxHp: 25, atk: 3, def: 3, exp: 12, gold: 10,
    color: '#9932CC',
    acts: ['Check', 'Poke', 'Wobble'],
    spareThreshold: 4,
    actEffects: {
      'Check': { msg: "JELLY BLOB - ATK 3 DEF 3\nSquishy but resilient.", spareMod: 0 },
      'Poke': { msg: "You poke it gently.\nJelly Blob jiggles happily!", spareMod: 2 },
      'Wobble': { msg: "You wobble together.\nJelly Blob feels understood!", spareMod: 2 }
    },
    patterns: ['blob', 'rain'],
    flavorText: ["Jelly Blob wobbles menacingly.", "Jelly Blob makes squishy sounds.", "Jelly Blob stares blankly."]
  },
  angry_clam: {
    name: 'Angry Clam',
    hp: 30, maxHp: 30, atk: 6, def: 4, exp: 15, gold: 12,
    color: '#696969',
    acts: ['Check', 'Apologize', 'Wait'],
    spareThreshold: 5,
    actEffects: {
      'Check': { msg: "ANGRY CLAM - ATK 6 DEF 4\nSomeone stepped on it.", spareMod: 0 },
      'Apologize': { msg: "You apologize sincerely.\nAngry Clam considers it.", spareMod: 2 },
      'Wait': { msg: "You wait patiently.\nAngry Clam calms down a bit.", spareMod: 2 }
    },
    patterns: ['snap', 'shell_spin'],
    flavorText: ["Angry Clam snaps aggressively.", "Angry Clam grumbles.", "Angry Clam is still angry."]
  },
  water_wisp: {
    name: 'Water Wisp',
    hp: 22, maxHp: 22, atk: 7, def: 1, exp: 18, gold: 15,
    color: '#00CED1',
    acts: ['Check', 'Listen', 'Flow'],
    spareThreshold: 4,
    actEffects: {
      'Check': { msg: "WATER WISP - ATK 7 DEF 1\nA spirit of the current.", spareMod: 0 },
      'Listen': { msg: "You listen to its whispers.\nWater Wisp feels heard!", spareMod: 2 },
      'Flow': { msg: "You move with the current.\nWater Wisp respects you!", spareMod: 2 }
    },
    patterns: ['stream', 'vortex'],
    flavorText: ["Water Wisp flows gracefully.", "Water Wisp whispers secrets.", "Water Wisp pulses with energy."]
  },
  pike_phantom: {
    name: 'Pike Phantom',
    hp: 28, maxHp: 28, atk: 8, def: 2, exp: 20, gold: 18,
    color: '#2F4F4F',
    acts: ['Check', 'Stare', 'Swim'],
    spareThreshold: 5,
    actEffects: {
      'Check': { msg: "PIKE PHANTOM - ATK 8 DEF 2\nA ghostly predator.", spareMod: 0 },
      'Stare': { msg: "You hold its gaze.\nPike Phantom is impressed!", spareMod: 2 },
      'Swim': { msg: "You swim fearlessly.\nPike Phantom nods!", spareMod: 3 }
    },
    patterns: ['dash', 'circle'],
    flavorText: ["Pike Phantom lurks ominously.", "Pike Phantom phases in and out.", "Pike Phantom eyes you hungrily."]
  },
  current_elemental: {
    name: 'Current Elemental',
    hp: 35, maxHp: 35, atk: 9, def: 3, exp: 25, gold: 20,
    color: '#4169E1',
    acts: ['Check', 'Ride', 'Surrender'],
    spareThreshold: 5,
    actEffects: {
      'Check': { msg: "CURRENT ELEMENTAL - ATK 9 DEF 3\nPure river energy.", spareMod: 0 },
      'Ride': { msg: "You ride its flow!\nCurrent Elemental is amused!", spareMod: 2 },
      'Surrender': { msg: "You let the current take you.\nCurrent Elemental respects this!", spareMod: 3 }
    },
    patterns: ['rapids', 'multi_stream'],
    flavorText: ["Current Elemental rushes past.", "Current Elemental surges with power.", "Current Elemental crashes and roars."]
  },
  dam_spirit: {
    name: 'Dam Spirit',
    hp: 40, maxHp: 40, atk: 10, def: 4, exp: 30, gold: 25,
    color: '#8B8682',
    acts: ['Check', 'Mourn', 'Promise'],
    spareThreshold: 5,
    actEffects: {
      'Check': { msg: "DAM SPIRIT - ATK 10 DEF 4\nTrapped between worlds.", spareMod: 0 },
      'Mourn': { msg: "You mourn with them.\nDam Spirit finds peace.", spareMod: 3 },
      'Promise': { msg: "You promise to free the river.\nDam Spirit believes you!", spareMod: 3 }
    },
    patterns: ['haunt', 'wail'],
    flavorText: ["Dam Spirit wails mournfully.", "Dam Spirit flickers sadly.", "Dam Spirit reaches out..."]
  },
  beaver_ghost: {
    name: 'Beaver Ghost',
    hp: 45, maxHp: 45, atk: 11, def: 5, exp: 35, gold: 30,
    color: '#DEB887',
    acts: ['Check', 'Forgive', 'Remember'],
    spareThreshold: 6,
    actEffects: {
      'Check': { msg: "BEAVER GHOST - ATK 11 DEF 5\nRegrets building the dam.", spareMod: 0 },
      'Forgive': { msg: "You offer forgiveness.\nBeaver Ghost weeps with relief!", spareMod: 3 },
      'Remember': { msg: "You share river memories.\nBeaver Ghost smiles!", spareMod: 3 }
    },
    patterns: ['construct', 'guilt'],
    flavorText: ["Beaver Ghost builds nervously.", "Beaver Ghost looks ashamed.", "Beaver Ghost gnaws anxiously."]
  },
  snapjaw: {
    name: 'SNAPJAW',
    hp: 150, maxHp: 150, atk: 12, def: 5, exp: 100, gold: 50,
    color: '#FF4500',
    isBoss: true,
    acts: ['Check', 'Flatter', 'Dodge', 'Compliment'],
    spareThreshold: 8,
    actEffects: {
      'Check': { msg: "SNAPJAW - ATK 12 DEF 5\nKing of the Coral Caves.\nHis claws can crush coral!", spareMod: 0 },
      'Flatter': { msg: "You praise his mighty claws.\nSnapjaw puffs with pride!", spareMod: 2 },
      'Dodge': { msg: "You dodge impressively.\nSnapjaw respects your agility!", spareMod: 2 },
      'Compliment': { msg: "You compliment his shell.\nSnapjaw tries to hide a smile!", spareMod: 2 }
    },
    patterns: ['boss_claw', 'boss_sweep', 'boss_rain'],
    flavorText: ["SNAPJAW clacks menacingly!", "SNAPJAW eyes you with disdain!", "SNAPJAW prepares a devastating attack!"]
  },
  current_king: {
    name: 'CURRENT KING',
    hp: 200, maxHp: 200, atk: 15, def: 4, exp: 150, gold: 75,
    color: '#00BFFF',
    isBoss: true,
    acts: ['Check', 'Swim', 'Plea', 'Harmonize'],
    spareThreshold: 10,
    actEffects: {
      'Check': { msg: "CURRENT KING - ATK 15 DEF 4\nRuler of the Rapids.\nControls the very water itself!", spareMod: 0 },
      'Swim': { msg: "You swim with the current.\nCurrent King is impressed!", spareMod: 2 },
      'Plea': { msg: "You explain your quest.\nCurrent King listens...", spareMod: 3 },
      'Harmonize': { msg: "You flow with his rhythm.\nCurrent King feels connected!", spareMod: 3 }
    },
    patterns: ['boss_wave', 'boss_vortex', 'boss_tsunami'],
    flavorText: ["CURRENT KING surges with power!", "CURRENT KING commands the waters!", "CURRENT KING creates massive waves!"]
  },
  brutus: {
    name: 'DAM MASTER BRUTUS',
    hp: 300, maxHp: 300, atk: 20, def: 8, exp: 300, gold: 100,
    color: '#8B4513',
    isBoss: true,
    isFinal: true,
    acts: ['Check', 'Reason', 'Empathize', 'Forgive', 'Embrace'],
    spareThreshold: 15,
    actEffects: {
      'Check': { msg: "DAM MASTER BRUTUS\nATK 20 DEF 8\nThe beaver who built the dam.\nHe lost his family in a flood\nand vowed to control the water.", spareMod: 0 },
      'Reason': { msg: "You explain how the dam\nhurts others.\nBrutus hesitates...", spareMod: 3 },
      'Empathize': { msg: "You share that you too\nhave lost things.\nBrutus's eyes soften.", spareMod: 4 },
      'Forgive': { msg: "You forgive him for\nwhat he's done.\nBrutus is shaken.", spareMod: 4 },
      'Embrace': { msg: "You offer a paw.\nBrutus trembles...\n\"...Thank you.\"", spareMod: 5 }
    },
    patterns: ['boss_dam', 'boss_construct', 'boss_flood', 'boss_desperation'],
    flavorText: [
      "BRUTUS stands resolute!",
      "BRUTUS remembers his family...",
      "BRUTUS attacks with desperate fury!",
      "BRUTUS is fighting back tears!",
      "BRUTUS questions everything!"
    ]
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIALOGUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const dialogues = {
  game_intro: {
    lines: [
      { speaker: 'Narrator', text: 'Long ago, the rivers flowed free and wild...' },
      { speaker: 'Narrator', text: 'Until the Great Dam was built, trapping the waters underground.' },
      { speaker: 'Narrator', text: 'You are OTTO, a young otter who fell into the depths.' },
      { speaker: 'Narrator', text: 'Your journey home will test your COURAGE... and your HEART.' }
    ],
    callback: 'intro_done'
  },
  sheldon_intro: {
    lines: [
      { speaker: 'Sheldon', text: 'Hey hey hey! You okay there, furball?' },
      { speaker: 'Sheldon', text: "Name's Sheldon! Sheldon the Shrimp! ðŸ¦" },
      { speaker: 'Sheldon', text: "I saw you fall! That was like... WHOOSH! SPLASH! Wow!" },
      { speaker: 'Sheldon', text: "Listen, I know this place pretty well. Wanna team up?" },
      { speaker: 'Sheldon', text: "I mean, I can't fight or anything. But I provide MORAL SUPPORT!" },
      { speaker: 'Sheldon', text: "Plus I'm HILARIOUS. You'll see. Let's go!" }
    ],
    callback: 'sheldon_joined'
  },
  elder_intro: {
    lines: [
      { speaker: 'Elder Otter', text: 'Ah, a young one from the surface...' },
      { speaker: 'Elder Otter', text: 'You seek the way out, yes?' },
      { speaker: 'Elder Otter', text: 'The path leads through the Coral Caves, then the Rapids...' },
      { speaker: 'Elder Otter', text: 'And finally to the Great Dam itself.' },
      { speaker: 'Elder Otter', text: 'Many creatures here are frightened. You can FIGHT them...' },
      { speaker: 'Elder Otter', text: 'Or show them MERCY. The choice... is yours.' },
      { speaker: 'Elder Otter', text: 'Remember: Use Z to confirm, X to cancel.' },
      { speaker: 'Elder Otter', text: 'And SHIFT lets you DIVE underwater in battle!' },
      { speaker: 'Elder Otter', text: 'Diving lets you phase through CYAN attacks.' },
      { speaker: 'Elder Otter', text: 'May the currents guide you, young one.' }
    ]
  },
  snapjaw_intro: {
    lines: [
      { speaker: '???', text: 'HALT!' },
      { speaker: 'SNAPJAW', text: 'No one passes through MY caves!' },
      { speaker: 'SNAPJAW', text: "I am SNAPJAW! King of the Coral Caves!" },
      { speaker: 'SNAPJAW', text: 'And YOU look like... dinner!' },
      { speaker: 'Sheldon', text: 'Oh no oh no oh no not this guy again!' },
      { speaker: 'SNAPJAW', text: 'SILENCE, APPETIZER!' }
    ],
    callback: 'snapjaw_battle'
  },
  current_intro: {
    lines: [
      { speaker: '???', text: 'Who disturbs my waters?' },
      { speaker: 'CURRENT KING', text: 'I am the CURRENT KING!' },
      { speaker: 'CURRENT KING', text: 'Ruler of all that flows!' },
      { speaker: 'CURRENT KING', text: 'Why do you trespass in my rapids, land-dweller?' },
      { speaker: 'Sheldon', text: 'We just want to get to the Dam!' },
      { speaker: 'CURRENT KING', text: 'The Dam... that cursed structure...' },
      { speaker: 'CURRENT KING', text: 'Very well. PROVE your worth!' }
    ],
    callback: 'current_battle'
  },
  dam_arrival: {
    lines: [
      { speaker: 'Narrator', text: 'The Great Dam looms before you...' },
      { speaker: 'Narrator', text: 'Countless logs, stacked by desperate paws.' },
      { speaker: 'Sheldon', text: "Otto... this is it. Whatever happens..." },
      { speaker: 'Sheldon', text: "I'm glad I met you, buddy." }
    ]
  },
  brutus_intro: {
    lines: [
      { speaker: 'BRUTUS', text: '...' },
      { speaker: 'BRUTUS', text: 'So. You made it.' },
      { speaker: 'BRUTUS', text: "I am Brutus. I built this dam." },
      { speaker: 'BRUTUS', text: 'Do you know WHY?' },
      { speaker: 'Sheldon', text: '...' },
      { speaker: 'BRUTUS', text: 'The flood took everything from me.' },
      { speaker: 'BRUTUS', text: 'My family. My home. My life.' },
      { speaker: 'BRUTUS', text: 'I will NEVER let the waters run wild again!' },
      { speaker: 'BRUTUS', text: 'And if you want to destroy my life\'s work...' },
      { speaker: 'BRUTUS', text: 'YOU WILL HAVE TO GO THROUGH ME!' }
    ],
    callback: 'brutus_battle'
  },
  snapjaw_spared: {
    lines: [
      { speaker: 'SNAPJAW', text: '...You... you spared me?' },
      { speaker: 'SNAPJAW', text: "No one's ever done that before." },
      { speaker: 'SNAPJAW', text: 'Maybe... maybe I was wrong about surface folk.' },
      { speaker: 'SNAPJAW', text: 'Go. The path to the Rapids is open.' },
      { speaker: 'Sheldon', text: "WE DID IT! You're amazing, Otto!" }
    ]
  },
  current_spared: {
    lines: [
      { speaker: 'CURRENT KING', text: 'Incredible... You resisted my full power...' },
      { speaker: 'CURRENT KING', text: 'Not through strength, but through understanding.' },
      { speaker: 'CURRENT KING', text: 'Perhaps you CAN free the river.' },
      { speaker: 'CURRENT KING', text: 'Go to the Dam. End this imprisonment.' },
      { speaker: 'Sheldon', text: "Two bosses down! We're unstoppable!" }
    ]
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let audioCtx = null;
let musicGain = null;
let currentMusic = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.3;
  musicGain.connect(audioCtx.destination);
}

function playNote(freq, duration, type = 'square', volume = 0.3) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(volume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playSound(name) {
  if (!audioCtx) return;
  const sounds = {
    select: () => playNote(440, 0.1, 'square', 0.2),
    confirm: () => { playNote(523, 0.1, 'square', 0.2); setTimeout(() => playNote(659, 0.1, 'square', 0.2), 100); },
    cancel: () => playNote(220, 0.15, 'square', 0.2),
    hit: () => playNote(100, 0.2, 'sawtooth', 0.3),
    hurt: () => { playNote(200, 0.1, 'sawtooth', 0.3); setTimeout(() => playNote(150, 0.15, 'sawtooth', 0.3), 100); },
    heal: () => { playNote(523, 0.1, 'sine', 0.2); setTimeout(() => playNote(659, 0.1, 'sine', 0.2), 100); setTimeout(() => playNote(784, 0.15, 'sine', 0.2), 200); },
    spare: () => { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playNote(f, 0.2, 'sine', 0.2), i * 100)); },
    encounter: () => { playNote(330, 0.15, 'square', 0.3); setTimeout(() => playNote(220, 0.2, 'square', 0.3), 150); },
    dive: () => playNote(150, 0.2, 'sine', 0.2)
  };
  if (sounds[name]) sounds[name]();
}

const musicPatterns = {
  calm: { bpm: 80, notes: [262, 294, 330, 262, 294, 330, 349, 330, 294, 262], bass: [131, 131, 165, 165, 131, 131, 175, 165] },
  tense: { bpm: 100, notes: [220, 262, 220, 247, 220, 262, 294, 262], bass: [110, 110, 123, 123, 110, 110, 147, 131] },
  intense: { bpm: 120, notes: [330, 392, 330, 294, 330, 392, 440, 392], bass: [165, 165, 196, 196, 165, 165, 220, 196] },
  final: { bpm: 140, notes: [392, 440, 494, 523, 494, 440, 392, 349], bass: [196, 196, 247, 247, 262, 262, 196, 175] },
  battle: { bpm: 150, notes: [330, 330, 392, 330, 294, 330, 392, 440], bass: [165, 165, 196, 165, 147, 165, 196, 220] },
  boss: { bpm: 160, notes: [220, 262, 294, 330, 294, 262, 220, 175], bass: [110, 131, 147, 165, 147, 131, 110, 88] }
};

let musicInterval = null;
let musicNoteIndex = 0;

function playMusic(pattern) {
  stopMusic();
  if (!audioCtx || !musicPatterns[pattern]) return;
  const p = musicPatterns[pattern];
  const beatTime = 60000 / p.bpm;
  musicNoteIndex = 0;
  musicInterval = setInterval(() => {
    const note = p.notes[musicNoteIndex % p.notes.length];
    const bass = p.bass[musicNoteIndex % p.bass.length];
    playNote(note, beatTime / 1000 * 0.8, 'square', 0.15);
    playNote(bass, beatTime / 1000 * 0.8, 'triangle', 0.1);
    musicNoteIndex++;
  }, beatTime);
  currentMusic = pattern;
}

function stopMusic() {
  if (musicInterval) {
    clearInterval(musicInterval);
    musicInterval = null;
  }
  currentMusic = null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATTLE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let enemySpareProgress = 0;
let battleTurnCount = 0;

function startBattle(enemyId) {
  const template = enemies[enemyId];
  if (!template) return;
  
  currentEnemy = {
    ...template,
    hp: template.hp,
    spareProg: 0
  };
  
  inBattle = true;
  battleState = 'menu';
  battleMenuIndex = 0;
  bullets = [];
  playerBattle = { x: 97, y: 67, width: 16, height: 16, invincible: 0, diving: false };
  turnTimer = 0;
  battleTurnCount = 0;
  selectedAction = null;
  
  document.getElementById('battle-ui').classList.add('active');
  document.getElementById('dialogue-box').classList.remove('active');
  
  updateBattleUI();
  setBattleText(currentEnemy.flavorText[0]);
  
  if (currentEnemy.isBoss) {
    playMusic('boss');
  } else {
    playMusic('battle');
  }
  
  playSound('encounter');
  sheldonBattleComment('start');
}

function endBattle(victory, spared = false) {
  inBattle = false;
  document.getElementById('battle-ui').classList.remove('active');
  document.getElementById('battle-box').classList.remove('active');
  bullets = [];
  
  if (victory) {
    if (spared) {
      player.spares++;
      player.gold += Math.floor(currentEnemy.gold / 2);
      playSound('spare');
      sheldonBattleComment('spare');
      
      if (currentEnemy.isBoss) {
        bossesDefeated.push(currentEnemy.name.toLowerCase().replace(/\s/g, '_'));
        
        if (currentEnemy.name === 'SNAPJAW') {
          setTimeout(() => showDialogue(dialogues.snapjaw_spared), 500);
        } else if (currentEnemy.name === 'CURRENT KING') {
          setTimeout(() => showDialogue(dialogues.current_spared), 500);
        } else if (currentEnemy.isFinal) {
          setTimeout(() => showEnding('pacifist'), 500);
          return;
        }
      }
    } else {
      player.kills++;
      player.exp += currentEnemy.exp;
      player.gold += currentEnemy.gold;
      sheldonBattleComment('kill');
      
      const levelThresholds = [0, 10, 30, 70, 120, 200, 300, 500];
      while (player.lv < levelThresholds.length && player.exp >= levelThresholds[player.lv]) {
        player.lv++;
        player.maxHp += 4;
        player.hp = player.maxHp;
        player.atk += 2;
      }
      
      if (currentEnemy.isBoss) {
        bossesDefeated.push(currentEnemy.name.toLowerCase().replace(/\s/g, '_'));
        
        if (currentEnemy.isFinal) {
          setTimeout(() => showEnding('genocide'), 500);
          return;
        }
      }
    }
    
    updateSheldonMood();
    saveGame();
  }
  
  playMusic(areas[currentArea].music);
  currentEnemy = null;
}

function updateSheldonMood() {
  if (player.kills === 0) {
    sheldonMood = 'normal';
  } else if (player.kills < 5) {
    sheldonMood = 'warning1';
  } else if (player.kills < 10) {
    sheldonMood = 'warning2';
  } else if (player.kills < 20) {
    sheldonMood = 'serious';
  } else {
    sheldonMood = 'genocide';
  }
}

function sheldonBattleComment(type) {
  const pool = sheldonMood === 'normal' || sheldonMood === 'warning1' 
    ? sheldonDialogue.normal 
    : sheldonDialogue.genocide;
  
  let comments;
  if (type === 'start') {
    comments = pool.battle_start || ['...'];
  } else if (type === 'spare') {
    comments = pool.spare || ["..."];
  } else if (type === 'kill') {
    if (sheldonMood === 'normal') {
      comments = ["Oh... okay.", "Was that necessary?", "..."];
    } else {
      comments = sheldonDialogue.genocide[sheldonMood] || sheldonDialogue.genocide.serious;
    }
  } else {
    comments = pool.battle_win || ['...'];
  }
  
  showSheldonComment(comments[Math.floor(Math.random() * comments.length)]);
}

function showSheldonComment(text) {
  const box = document.getElementById('companion-box');
  box.querySelector('.text').textContent = text;
  box.classList.add('active');
  sheldonTimer = 4000;
}

function updateBattleUI() {
  if (!currentEnemy) return;
  
  document.querySelector('#enemy-display .enemy-name').textContent = currentEnemy.name;
  const hpPercent = Math.max(0, (currentEnemy.hp / currentEnemy.maxHp) * 100);
  document.querySelector('#enemy-display .hp-fill').style.width = hpPercent + '%';
  
  document.getElementById('current-hp').textContent = player.hp;
  document.getElementById('max-hp').textContent = player.maxHp;
  document.querySelector('#player-stats .hp-fill').style.width = (player.hp / player.maxHp * 100) + '%';
}

function setBattleText(text) {
  document.getElementById('battle-text').textContent = text;
}

function showSubMenu(items) {
  subMenuItems = items;
  subMenuIndex = 0;
  battleState = 'submenu';
  
  const subMenu = document.getElementById('sub-menu');
  subMenu.innerHTML = '';
  items.forEach((item, i) => {
    const btn = document.createElement('button');
    btn.textContent = item;
    btn.className = i === 0 ? 'selected' : '';
    btn.onclick = () => selectSubMenuItem(i);
    subMenu.appendChild(btn);
  });
  subMenu.classList.add('active');
}

function hideSubMenu() {
  document.getElementById('sub-menu').classList.remove('active');
  subMenuItems = [];
  battleState = 'menu';
}

function selectSubMenuItem(index) {
  subMenuIndex = index;
  updateSubMenuSelection();
}

function updateSubMenuSelection() {
  const buttons = document.querySelectorAll('#sub-menu button');
  buttons.forEach((btn, i) => {
    btn.className = i === subMenuIndex ? 'selected' : '';
  });
}

function executeBattleAction(action, subAction = null) {
  hideSubMenu();
  
  if (action === 'fight') {
    const damage = Math.max(1, player.atk - currentEnemy.def + Math.floor(Math.random() * 3));
    currentEnemy.hp -= damage;
    playSound('hit');
    screenShake = 10;
    setBattleText(`You dealt ${damage} damage!`);
    
    setTimeout(() => {
      if (currentEnemy.hp <= 0) {
        setBattleText(`${currentEnemy.name} was defeated!`);
        setTimeout(() => endBattle(true, false), 1000);
      } else {
        startEnemyTurn();
      }
    }, 1000);
    
  } else if (action === 'act') {
    const effect = currentEnemy.actEffects[subAction];
    if (effect) {
      currentEnemy.spareProg += effect.spareMod;
      setBattleText(effect.msg);
      
      setTimeout(() => {
        if (currentEnemy.spareProg >= currentEnemy.spareThreshold) {
          setBattleText(`${currentEnemy.name}'s name turned YELLOW!`);
        }
        setTimeout(() => startEnemyTurn(), 1000);
      }, 1500);
    }
    
  } else if (action === 'item') {
    const result = useItem(subAction);
    setBattleText(result);
    playSound('heal');
    updateBattleUI();
    setTimeout(() => startEnemyTurn(), 1500);
    
  } else if (action === 'mercy') {
    if (subAction === 'Spare') {
      if (currentEnemy.spareProg >= currentEnemy.spareThreshold) {
        setBattleText(`You spared ${currentEnemy.name}!`);
        setTimeout(() => endBattle(true, true), 1500);
      } else {
        setBattleText(`${currentEnemy.name} isn't ready to be spared.`);
        setTimeout(() => startEnemyTurn(), 1500);
      }
    } else if (subAction === 'Flee') {
      if (currentEnemy.isBoss) {
        setBattleText("You can't run from a boss!");
        setTimeout(() => startEnemyTurn(), 1500);
      } else if (Math.random() > 0.3) {
        setBattleText('Got away safely!');
        setTimeout(() => endBattle(false), 1000);
      } else {
        setBattleText("Couldn't escape!");
        setTimeout(() => startEnemyTurn(), 1000);
      }
    }
  }
}

function startEnemyTurn() {
  battleState = 'dodge';
  battleTurnCount++;
  
  document.getElementById('battle-box').classList.add('active');
  
  const flavor = currentEnemy.flavorText[Math.floor(Math.random() * currentEnemy.flavorText.length)];
  setBattleText(flavor);
  
  const patterns = currentEnemy.patterns;
  const pattern = patterns[Math.floor(Math.random() * patterns.length)];
  
  turnTimer = 0;
  spawnBulletPattern(pattern);
}

function endEnemyTurn() {
  battleState = 'menu';
  battleMenuIndex = 0;
  bullets = [];
  playerBattle.diving = false;
  
  document.getElementById('battle-box').classList.remove('active');
  
  updateMenuSelection();
  setBattleText('What will you do?');
}

function updateMenuSelection() {
  const buttons = document.querySelectorAll('#battle-menu button');
  buttons.forEach((btn, i) => {
    btn.classList.toggle('selected', i === battleMenuIndex);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BULLET PATTERNS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawnBulletPattern(pattern) {
  const boxW = 194, boxH = 134;
  const cx = boxW / 2, cy = boxH / 2;
  
  switch(pattern) {
    case 'simple':
      for (let i = 0; i < 8; i++) {
        setTimeout(() => {
          bullets.push({
            x: Math.random() * boxW, y: -10,
            vx: 0, vy: 2 + Math.random(),
            size: 8, color: '#fff', type: 'normal'
          });
        }, i * 200);
      }
      setTimeout(() => endEnemyTurn(), 3000);
      break;
      
    case 'wave':
      for (let i = 0; i < 12; i++) {
        setTimeout(() => {
          bullets.push({
            x: -10, y: 30 + Math.sin(i * 0.5) * 40,
            vx: 2.5, vy: 0,
            size: 8, color: '#fff', type: 'normal'
          });
        }, i * 150);
      }
      setTimeout(() => endEnemyTurn(), 3500);
      break;
      
    case 'crab_walk':
      for (let i = 0; i < 6; i++) {
        setTimeout(() => {
          bullets.push({
            x: i % 2 === 0 ? -10 : boxW + 10,
            y: 20 + i * 20,
            vx: i % 2 === 0 ? 3 : -3,
            vy: 0,
            size: 10, color: '#8B4513', type: 'normal'
          });
        }, i * 300);
      }
      setTimeout(() => endEnemyTurn(), 3500);
      break;
      
    case 'pinch':
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          const angle = (i / 4) * Math.PI * 2;
          bullets.push({
            x: cx + Math.cos(angle) * 80,
            y: cy + Math.sin(angle) * 60,
            vx: -Math.cos(angle) * 2,
            vy: -Math.sin(angle) * 2,
            size: 12, color: '#ff4444', type: 'normal'
          });
        }, i * 400);
      }
      setTimeout(() => endEnemyTurn(), 3000);
      break;
      
    case 'spiral':
      let spiralAngle = 0;
      const spiralInterval = setInterval(() => {
        bullets.push({
          x: cx, y: cy,
          vx: Math.cos(spiralAngle) * 2,
          vy: Math.sin(spiralAngle) * 2,
          size: 6, color: '#FF69B4', type: 'normal'
        });
        spiralAngle += 0.5;
      }, 100);
      setTimeout(() => { clearInterval(spiralInterval); }, 2500);
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'burst':
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        bullets.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * 2.5,
          vy: Math.sin(angle) * 2.5,
          size: 8, color: '#ff88ff', type: 'normal'
        });
      }
      setTimeout(() => {
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2 + 0.4;
          bullets.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * 2.5,
            vy: Math.sin(angle) * 2.5,
            size: 8, color: '#00ffff', type: 'dive'
          });
        }
      }, 800);
      setTimeout(() => endEnemyTurn(), 3500);
      break;
      
    case 'blob':
      for (let i = 0; i < 15; i++) {
        setTimeout(() => {
          bullets.push({
            x: Math.random() * boxW,
            y: -10,
            vx: (Math.random() - 0.5) * 2,
            vy: 1.5 + Math.random(),
            size: 10 + Math.random() * 6,
            color: '#9932CC', type: 'normal'
          });
        }, i * 150);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'rain':
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          bullets.push({
            x: Math.random() * boxW, y: -5,
            vx: 0, vy: 3,
            size: 5, color: i % 3 === 0 ? '#00ffff' : '#9932CC',
            type: i % 3 === 0 ? 'dive' : 'normal'
          });
        }, i * 120);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'snap':
      setTimeout(() => {
        bullets.push({ x: -30, y: cy - 20, vx: 4, vy: 0, size: 25, color: '#888', type: 'normal' });
        bullets.push({ x: boxW + 30, y: cy + 20, vx: -4, vy: 0, size: 25, color: '#888', type: 'normal' });
      }, 500);
      setTimeout(() => endEnemyTurn(), 2500);
      break;
      
    case 'shell_spin':
      let shellAngle = 0;
      const shellInt = setInterval(() => {
        for (let i = 0; i < 3; i++) {
          const a = shellAngle + (i / 3) * Math.PI * 2;
          bullets.push({
            x: cx + Math.cos(a) * 20,
            y: cy + Math.sin(a) * 20,
            vx: Math.cos(a) * 3,
            vy: Math.sin(a) * 3,
            size: 8, color: '#696969', type: 'normal'
          });
        }
        shellAngle += 0.8;
      }, 400);
      setTimeout(() => clearInterval(shellInt), 2000);
      setTimeout(() => endEnemyTurn(), 3500);
      break;
      
    case 'stream':
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          for (let j = 0; j < 5; j++) {
            setTimeout(() => {
              bullets.push({
                x: -10, y: 30 + i * 35,
                vx: 4, vy: 0,
                size: 8, color: '#00CED1', type: 'normal'
              });
            }, j * 100);
          }
        }, i * 600);
      }
      setTimeout(() => endEnemyTurn(), 3500);
      break;
      
    case 'vortex':
      let vortAngle = 0;
      const vortInt = setInterval(() => {
        bullets.push({
          x: cx + Math.cos(vortAngle) * 70,
          y: cy + Math.sin(vortAngle) * 50,
          vx: Math.cos(vortAngle + Math.PI/2) * 2,
          vy: Math.sin(vortAngle + Math.PI/2) * 2,
          size: 6, color: '#00ffff', type: 'dive'
        });
        vortAngle += 0.4;
      }, 80);
      setTimeout(() => clearInterval(vortInt), 2500);
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'dash':
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          const startY = Math.random() * boxH;
          for (let j = 0; j < 5; j++) {
            bullets.push({
              x: -10 - j * 15,
              y: startY,
              vx: 5, vy: 0,
              size: 10, color: '#2F4F4F', type: 'normal'
            });
          }
        }, i * 700);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'circle':
      setTimeout(() => {
        for (let i = 0; i < 16; i++) {
          const angle = (i / 16) * Math.PI * 2;
          bullets.push({
            x: cx + Math.cos(angle) * 80,
            y: cy + Math.sin(angle) * 60,
            vx: -Math.cos(angle) * 1.5,
            vy: -Math.sin(angle) * 1.5,
            size: 8, color: '#44ff44', type: 'normal'
          });
        }
      }, 300);
      setTimeout(() => endEnemyTurn(), 3000);
      break;
      
    case 'rapids':
      for (let i = 0; i < 25; i++) {
        setTimeout(() => {
          bullets.push({
            x: boxW + 10,
            y: Math.random() * boxH,
            vx: -4 - Math.random() * 2,
            vy: (Math.random() - 0.5) * 2,
            size: 6 + Math.random() * 4,
            color: i % 4 === 0 ? '#00ffff' : '#4169E1',
            type: i % 4 === 0 ? 'dive' : 'normal'
          });
        }, i * 100);
      }
      setTimeout(() => endEnemyTurn(), 4500);
      break;
      
    case 'multi_stream':
      for (let wave = 0; wave < 3; wave++) {
        setTimeout(() => {
          for (let i = 0; i < 6; i++) {
            bullets.push({
              x: (i + 0.5) * (boxW / 6),
              y: -10,
              vx: 0, vy: 3,
              size: 8, color: '#4169E1', type: 'normal'
            });
          }
        }, wave * 800);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'haunt':
      for (let i = 0; i < 10; i++) {
        setTimeout(() => {
          const b = {
            x: Math.random() * boxW,
            y: Math.random() * boxH,
            vx: 0, vy: 0,
            size: 0, maxSize: 15,
            color: '#8B8682', type: 'ghost',
            phase: 'grow', timer: 0
          };
          bullets.push(b);
        }, i * 250);
      }
      setTimeout(() => endEnemyTurn(), 4500);
      break;
      
    case 'wail':
      for (let i = 0; i < 8; i++) {
        setTimeout(() => {
          bullets.push({
            x: cx, y: -10,
            vx: (Math.random() - 0.5) * 3,
            vy: 2,
            size: 10, color: '#aaaaaa',
            type: 'normal', wave: true, waveAmp: 30, waveFreq: 0.1, startX: cx
          });
        }, i * 200);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'construct':
      for (let i = 0; i < 12; i++) {
        setTimeout(() => {
          bullets.push({
            x: Math.random() * boxW,
            y: -20,
            vx: 0, vy: 2.5,
            size: 8, width: 30, height: 10,
            color: '#DEB887', type: 'rect'
          });
        }, i * 200);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'guilt':
      let guiltAngle = 0;
      const guiltInt = setInterval(() => {
        bullets.push({
          x: cx, y: cy,
          vx: Math.cos(guiltAngle) * 2,
          vy: Math.sin(guiltAngle) * 2,
          size: 6, color: '#00ffff', type: 'dive'
        });
        bullets.push({
          x: cx, y: cy,
          vx: Math.cos(guiltAngle + Math.PI) * 2,
          vy: Math.sin(guiltAngle + Math.PI) * 2,
          size: 6, color: '#ffffff', type: 'normal'
        });
        guiltAngle += 0.3;
      }, 100);
      setTimeout(() => clearInterval(guiltInt), 3000);
      setTimeout(() => endEnemyTurn(), 4500);
      break;
      
    case 'boss_claw':
      for (let wave = 0; wave < 3; wave++) {
        setTimeout(() => {
          for (let i = 0; i < 5; i++) {
            bullets.push({
              x: wave % 2 === 0 ? -20 : boxW + 20,
              y: 10 + i * 25,
              vx: wave % 2 === 0 ? 4 : -4,
              vy: 0,
              size: 12, color: '#FF4500', type: 'normal'
            });
          }
        }, wave * 700);
      }
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'boss_sweep':
      let sweepY = 0;
      const sweepInt = setInterval(() => {
        bullets.push({
          x: -10, y: sweepY,
          vx: 5, vy: 0.5,
          size: 10, color: '#ff6600', type: 'normal'
        });
        sweepY += 8;
        if (sweepY > boxH) sweepY = 0;
      }, 80);
      setTimeout(() => clearInterval(sweepInt), 3000);
      setTimeout(() => endEnemyTurn(), 4500);
      break;
      
    case 'boss_rain':
      for (let i = 0; i < 30; i++) {
        setTimeout(() => {
          bullets.push({
            x: Math.random() * boxW, y: -10,
            vx: (Math.random() - 0.5) * 2,
            vy: 3 + Math.random() * 2,
            size: 8, color: i % 5 === 0 ? '#00ffff' : '#FF4500',
            type: i % 5 === 0 ? 'dive' : 'normal'
          });
        }, i * 100);
      }
      setTimeout(() => endEnemyTurn(), 5000);
      break;
      
    case 'boss_wave':
      for (let wave = 0; wave < 4; wave++) {
        setTimeout(() => {
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI;
            bullets.push({
              x: cx, y: boxH + 10,
              vx: Math.cos(angle) * 3,
              vy: -Math.sin(angle) * 3 - 1,
              size: 10, color: '#00BFFF', type: 'normal'
            });
          }
        }, wave * 600);
      }
      setTimeout(() => endEnemyTurn(), 4500);
      break;
      
    case 'boss_vortex':
      let bvAngle = 0;
      const bvInt = setInterval(() => {
        for (let i = 0; i < 2; i++) {
          const a = bvAngle + i * Math.PI;
          bullets.push({
            x: cx + Math.cos(a) * 60,
            y: cy + Math.sin(a) * 40,
            vx: Math.cos(a + Math.PI/2) * 2.5,
            vy: Math.sin(a + Math.PI/2) * 2.5,
            size: 8, color: '#00ffff', type: 'dive'
          });
        }
        bvAngle += 0.25;
      }, 100);
      setTimeout(() => clearInterval(bvInt), 3500);
      setTimeout(() => endEnemyTurn(), 5000);
      break;
      
    case 'boss_tsunami':
      setTimeout(() => {
        for (let i = 0; i < 20; i++) {
          bullets.push({
            x: boxW + 10 + i * 5,
            y: 20 + Math.sin(i * 0.5) * 40,
            vx: -3, vy: 0,
            size: 12, color: '#1E90FF', type: 'normal'
          });
        }
      }, 500);
      setTimeout(() => endEnemyTurn(), 4000);
      break;
      
    case 'boss_dam':
      const logPattern = [0, 1, 0, 1, 1, 0, 0, 1, 0, 1];
      logPattern.forEach((side, i) => {
        setTimeout(() => {
          bullets.push({
            x: side === 0 ? boxW * 0.25 : boxW * 0.75,
            y: -20,
            vx: 0, vy: 3,
            size: 8, width: 40, height: 12,
            color: '#8B4513', type: 'rect'
          });
        }, i * 300);
      });
      setTimeout(() => endEnemyTurn(), 5000);
      break;
      
    case 'boss_construct':
      for (let layer = 0; layer < 4; layer++) {
        setTimeout(() => {
          for (let i = 0; i < 6; i++) {
            bullets.push({
              x: 10 + i * 30,
              y: boxH + 10,
              vx: 0, vy: -2 - layer * 0.5,
              size: 10, color: '#A0522D', type: 'normal'
            });
          }
        }, layer * 500);
      }
      setTimeout(() => endEnemyTurn(), 4500);
      break;
      
    case 'boss_flood':
      for (let i = 0; i < 40; i++) {
        setTimeout(() => {
          const side = Math.floor(Math.random() * 4);
          let x, y, vx, vy;
          if (side === 0) { x = -10; y = Math.random() * boxH; vx = 3; vy = 0; }
          else if (side === 1) { x = boxW + 10; y = Math.random() * boxH; vx = -3; vy = 0; }
          else if (side === 2) { x = Math.random() * boxW; y = -10; vx = 0; vy = 3; }
          else { x = Math.random() * boxW; y = boxH + 10; vx = 0; vy = -3; }
          
          bullets.push({
            x, y, vx, vy,
            size: 8, color: i % 6 === 0 ? '#00ffff' : '#4169E1',
            type: i % 6 === 0 ? 'dive' : 'normal'
          });
        }, i * 80);
      }
      setTimeout(() => endEnemyTurn(), 5500);
      break;
      
    case 'boss_desperation':
      let despAngle = 0;
      const despInt = setInterval(() => {
        bullets.push({
          x: cx, y: cy,
          vx: Math.cos(despAngle) * 2.5,
          vy: Math.sin(despAngle) * 2.5,
          size: 6, color: '#ff4444', type: 'normal'
        });
        if (Math.random() > 0.5) {
          bullets.push({
            x: Math.random() * boxW, y: -10,
            vx: 0, vy: 4,
            size: 10, color: '#00ffff', type: 'dive'
          });
        }
        despAngle += 0.4;
      }, 60);
      setTimeout(() => clearInterval(despInt), 4000);
      setTimeout(() => endEnemyTurn(), 5500);
      break;
      
    default:
      setTimeout(() => endEnemyTurn(), 2000);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIALOGUE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let dialogueIndex = 0;
let typingText = '';
let typingIndex = 0;
let typingTimer = 0;

function showDialogue(dlg, callback = null) {
  currentDialogue = dlg;
  dialogueIndex = 0;
  dialogueCallback = callback || dlg.callback;
  showCurrentLine();
  document.getElementById('dialogue-box').classList.add('active');
}

function showCurrentLine() {
  if (!currentDialogue || dialogueIndex >= currentDialogue.lines.length) {
    closeDialogue();
    return;
  }
  
  const line = currentDialogue.lines[dialogueIndex];
  document.getElementById('speaker').textContent = line.speaker;
  typingText = line.text;
  typingIndex = 0;
  document.getElementById('dialogue-text').textContent = '';
  document.getElementById('choices').innerHTML = '';
}

function updateDialogueTyping(dt) {
  if (!currentDialogue) return;
  
  typingTimer += dt;
  if (typingTimer > 30 && typingIndex < typingText.length) {
    typingTimer = 0;
    typingIndex++;
    document.getElementById('dialogue-text').textContent = typingText.substring(0, typingIndex);
    if (typingIndex % 2 === 0) playNote(400 + Math.random() * 100, 0.05, 'square', 0.1);
  }
}

function advanceDialogue() {
  if (!currentDialogue) return;
  
  if (typingIndex < typingText.length) {
    typingIndex = typingText.length;
    document.getElementById('dialogue-text').textContent = typingText;
    return;
  }
  
  dialogueIndex++;
  if (dialogueIndex >= currentDialogue.lines.length) {
    closeDialogue();
  } else {
    showCurrentLine();
  }
}

function closeDialogue() {
  const cb = dialogueCallback;
  currentDialogue = null;
  dialogueCallback = null;
  document.getElementById('dialogue-box').classList.remove('active');
  
  if (cb) {
    handleDialogueCallback(cb);
  }
}

function handleDialogueCallback(cb) {
  switch(cb) {
    case 'intro_done':
      if (!triggeredEvents.includes('sheldon_joined')) {
        setTimeout(() => showDialogue(dialogues.sheldon_intro), 500);
      }
      break;
    case 'sheldon_joined':
      triggeredEvents.push('sheldon_joined');
      showSheldonComment("Let's GO! Adventure awaits!");
      saveGame();
      break;
    case 'snapjaw_battle':
      setTimeout(() => startBattle('snapjaw'), 500);
      break;
    case 'current_battle':
      setTimeout(() => startBattle('current_king'), 500);
      break;
    case 'brutus_battle':
      setTimeout(() => startBattle('brutus'), 500);
      break;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENDINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showEnding(type) {
  const screen = document.getElementById('ending-screen');
  const title = document.getElementById('ending-title');
  const text = document.getElementById('ending-text');
  
  stopMusic();
  
  if (type === 'pacifist') {
    title.textContent = 'ðŸ¦¦ TRUE PACIFIST ENDING ðŸ¦¦';
    title.style.color = '#00ff00';
    text.innerHTML = `
      <p>You showed mercy to every creature you met.</p>
      <p>Even Brutus, consumed by grief, found peace through your kindness.</p>
      <p>Together, you dismantled the Dam piece by piece.</p>
      <p>The river flowed free once more, and the underground bloomed with life.</p>
      <p>You returned to the surface, but you never forgot your friends below.</p>
      <p>And Sheldon? He visits every summer. Best friends forever.</p>
      <p style="color: #ffff00; margin-top: 20px;">THE END</p>
      <p style="color: #888; font-size: 12px;">Kills: 0 | Spares: ${player.spares} | Time: ${formatTime(gameTime)}</p>
    `;
    playSound('spare');
  } else if (type === 'genocide') {
    title.textContent = 'ðŸ’€ GENOCIDE ENDING ðŸ’€';
    title.style.color = '#ff0000';
    
    if (player.kills >= 20) {
      text.innerHTML = `
        <p style="color: #ff0000;">You killed them all.</p>
        <p>Every creature. Every boss. Every innocent soul.</p>
        <p>The river runs red with your violence.</p>
        <p>And for what? Numbers? A "complete" run?</p>
        <p>...</p>
        <p>I know you're reading this.</p>
        <p>You, the player. Not Otto. YOU.</p>
        <p>Otto was just a puppet. YOU pulled the strings.</p>
        <p>Every death was YOUR choice.</p>
        <p>You could have shown mercy. You didn't.</p>
        <p>And now... there's nothing left.</p>
        <p>Just you. And the knowledge of what you did.</p>
        <p>Was it worth it?</p>
        <p style="color: #ff0000; margin-top: 20px;">THE END?</p>
        <p style="color: #888; font-size: 12px;">Kills: ${player.kills} | Spares: ${player.spares}</p>
      `;
    } else {
      text.innerHTML = `
        <p>You defeated Brutus with force.</p>
        <p>The Dam crumbled, but not through understanding.</p>
        <p>The river is free, but at what cost?</p>
        <p>The creatures below will remember your violence.</p>
        <p>You returned home, but something feels... wrong.</p>
        <p style="color: #ff6600; margin-top: 20px;">NEUTRAL ENDING</p>
        <p style="color: #888; font-size: 12px;">Kills: ${player.kills} | Spares: ${player.spares}</p>
      `;
    }
  }
  
  screen.style.display = 'flex';
  deleteSave();
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}m ${secs}s`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GAME_KEYS = new Set(['KeyW', 'KeyS', 'KeyA', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyZ', 'KeyX', 'Enter', 'Backspace', 'ShiftLeft', 'ShiftRight', 'Escape']);

window.addEventListener('keydown', e => {
  if (document.activeElement && document.activeElement.tagName === 'INPUT') {
    return;
  }
  
  if (GAME_KEYS.has(e.code)) {
    e.preventDefault();
  }
  
  if (keys[e.code]) return;
  keys[e.code] = true;
  
  handleKeyPress(e.code);
});

window.addEventListener('keyup', e => {
  if (document.activeElement && document.activeElement.tagName === 'INPUT') {
    return;
  }
  
  keys[e.code] = false;
  
  if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
    playerBattle.diving = false;
  }
});

function handleKeyPress(code) {
  if (gameState === 'menu') return;
  
  if (gameState === 'naming') {
    if (code === 'Escape') {
      document.getElementById('name-screen').style.display = 'none';
      document.getElementById('menu-screen').style.display = 'flex';
      gameState = 'menu';
    }
    return;
  }
  
  if (currentDialogue) {
    if (code === 'KeyZ' || code === 'Enter') {
      playSound('select');
      advanceDialogue();
    }
    return;
  }
  
  if (inBattle) {
    if (battleState === 'menu') {
      if (code === 'ArrowLeft' || code === 'KeyA') {
        battleMenuIndex = Math.max(0, battleMenuIndex - 1);
        playSound('select');
        updateMenuSelection();
      } else if (code === 'ArrowRight' || code === 'KeyD') {
        battleMenuIndex = Math.min(3, battleMenuIndex + 1);
        playSound('select');
        updateMenuSelection();
      } else if (code === 'KeyZ' || code === 'Enter') {
        playSound('confirm');
        const actions = ['fight', 'act', 'item', 'mercy'];
        const action = actions[battleMenuIndex];
        selectedAction = action;
        
        if (action === 'fight') {
          executeBattleAction('fight');
        } else if (action === 'act') {
          showSubMenu(currentEnemy.acts);
        } else if (action === 'item') {
          if (inventory.length === 0) {
            setBattleText('No items!');
          } else {
            showSubMenu(inventory);
          }
        } else if (action === 'mercy') {
          const mercyOptions = ['Spare'];
          if (!currentEnemy.isBoss) mercyOptions.push('Flee');
          showSubMenu(mercyOptions);
        }
      }
    } else if (battleState === 'submenu') {
      if (code === 'ArrowUp' || code === 'KeyW') {
        subMenuIndex = Math.max(0, subMenuIndex - 1);
        playSound('select');
        updateSubMenuSelection();
      } else if (code === 'ArrowDown' || code === 'KeyS') {
        subMenuIndex = Math.min(subMenuItems.length - 1, subMenuIndex + 1);
        playSound('select');
        updateSubMenuSelection();
      } else if (code === 'KeyZ' || code === 'Enter') {
        playSound('confirm');
        executeBattleAction(selectedAction, subMenuItems[subMenuIndex]);
      } else if (code === 'KeyX' || code === 'Backspace') {
        playSound('cancel');
        hideSubMenu();
      }
    } else if (battleState === 'dodge') {
      if (code === 'ShiftLeft' || code === 'ShiftRight') {
        playerBattle.diving = true;
        playSound('dive');
      }
    }
    return;
  }
  
  if (code === 'Escape') {
    saveGame();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function update(dt) {
  gameTime += dt / 1000;
  
  if (sheldonTimer > 0) {
    sheldonTimer -= dt;
    if (sheldonTimer <= 0) {
      document.getElementById('companion-box').classList.remove('active');
    }
  }
  
  if (screenShake > 0) {
    screenShake *= 0.9;
    if (screenShake < 0.5) screenShake = 0;
  }
  
  if (gameState !== 'playing') return;
  
  if (currentDialogue) {
    updateDialogueTyping(dt);
    return;
  }
  
  if (inBattle) {
    updateBattle(dt);
    return;
  }
  
  let dx = 0, dy = 0;
  if (keys['KeyW'] || keys['ArrowUp']) dy -= player.speed;
  if (keys['KeyS'] || keys['ArrowDown']) dy += player.speed;
  if (keys['KeyA'] || keys['ArrowLeft']) dx -= player.speed;
  if (keys['KeyD'] || keys['ArrowRight']) dx += player.speed;
  
  if (dx !== 0 && dy !== 0) {
    dx *= 0.707;
    dy *= 0.707;
  }
  
  const area = areas[currentArea];
  const newX = player.x + dx;
  const newY = player.y + dy;
  
  let canMoveX = true, canMoveY = true;
  const pRect = { x: newX - player.width/2, y: player.y - player.height/2, w: player.width, h: player.height };
  const pRectY = { x: player.x - player.width/2, y: newY - player.height/2, w: player.width, h: player.height };
  
  for (const obs of area.obstacles) {
    if (rectCollide(pRect, obs)) canMoveX = false;
    if (rectCollide(pRectY, obs)) canMoveY = false;
  }
  
  // Check collision with puzzle blocks
  if (currentPuzzle && currentPuzzle.type === "block_puzzle") {
    for (const block of currentPuzzle.blocks) {
      const blockRect = { x: block.x - block.w/2, y: block.y - block.h/2, w: block.w, h: block.h };
      if (rectCollide(pRect, blockRect)) canMoveX = false;
      if (rectCollide(pRectY, blockRect)) canMoveY = false;
    }
  }
  
  if (canMoveX) player.x = Math.max(player.width/2, Math.min(area.width - player.width/2, newX));
  if (canMoveY) player.y = Math.max(player.height/2, Math.min(area.height - player.height/2, newY));
  
  if (dx > 0) player.facing = 'right';
  else if (dx < 0) player.facing = 'left';
  else if (dy > 0) player.facing = 'down';
  else if (dy < 0) player.facing = 'up';
  
  for (const exit of area.exits) {
    if (player.x > exit.x && player.x < exit.x + exit.w &&
        player.y > exit.y && player.y < exit.y + exit.h) {
      if (exit.requireBoss && !bossesDefeated.includes(exit.requireBoss)) {
        continue;
      }
      if (exit.requirePuzzle) {
        const puzzle = puzzles[exit.requirePuzzle];
        if (puzzle && !puzzle.solved) {
          showSheldonComment("You need to solve the puzzle first!");
          continue;
        }
      }
      changeArea(exit.to, exit.spawnX, exit.spawnY);
      return;
    }
  }
  
  for (const item of area.items) {
    if (!itemsCollected.includes(item.id)) {
      const dist = Math.hypot(player.x - item.x, player.y - item.y);
      if (dist < 30) {
        if (inventory.length < maxInventory) {
          inventory.push(item.item);
          itemsCollected.push(item.id);
          showSheldonComment(`Ooh! You found ${item.item}!`);
          playSound('heal');
          saveGame();
        } else {
          showSheldonComment("Inventory full!");
        }
      }
    }
  }
  
  checkPuzzleInteraction();
  
  for (const evt of area.events) {
    if (evt.once && triggeredEvents.includes(evt.id)) continue;
    if (player.x > evt.x && player.x < evt.x + evt.w &&
        player.y > evt.y && player.y < evt.y + evt.h) {
      triggeredEvents.push(evt.id);
      if (dialogues[evt.dialogue]) {
        showDialogue(dialogues[evt.dialogue]);
      }
    }
  }
  
  for (const npc of area.npcs) {
    const dist = Math.hypot(player.x - npc.x, player.y - npc.y);
    if (dist < 40) {
      if (npc.boss) {
        if (!bossesDefeated.includes(npc.boss)) {
          if (dialogues[npc.dialogue]) {
            showDialogue(dialogues[npc.dialogue]);
          }
        }
      } else {
        if (dialogues[npc.dialogue] && !triggeredEvents.includes(npc.id)) {
          triggeredEvents.push(npc.id);
          showDialogue(dialogues[npc.dialogue]);
        }
      }
    }
  }
  
  let canSpawnMonsters = true;
  for (const puzzleArea of area.puzzles || []) {
    if (!puzzleArea.solved) {
      const puzzle = puzzles[puzzleArea.id];
      if (puzzle && !puzzle.solved) {
        const dist = Math.hypot(
          player.x - (puzzleArea.x + puzzleArea.w/2),
          player.y - (puzzleArea.y + puzzleArea.h/2)
        );
        if (dist < 100) {
          canSpawnMonsters = false;
          break;
        }
      }
    }
  }
  
  if (canSpawnMonsters && (dx !== 0 || dy !== 0) && Math.random() < area.encounterRate && !currentDialogue) {
    const enemyId = area.encounters[Math.floor(Math.random() * area.encounters.length)];
    startBattle(enemyId);
  }
  
  if (currentArea !== lastSheldonArea && !inBattle && !currentDialogue) {
    lastSheldonArea = currentArea;
    const areaComments = sheldonMood.startsWith('genocide') 
      ? sheldonDialogue.genocide.serious 
      : sheldonDialogue.normal[['murky', 'coral', 'rapids', 'dam'][currentArea]];
    if (areaComments) {
      setTimeout(() => {
        showSheldonComment(areaComments[Math.floor(Math.random() * areaComments.length)]);
      }, 1000);
    }
  }
}

function updateBattle(dt) {
  battleAnimFrame++;
  
  if (battleState === 'dodge') {
    turnTimer += dt;
    
    const speed = 3;
    if (keys['KeyW'] || keys['ArrowUp']) playerBattle.y -= speed;
    if (keys['KeyS'] || keys['ArrowDown']) playerBattle.y += speed;
    if (keys['KeyA'] || keys['ArrowLeft']) playerBattle.x -= speed;
    if (keys['KeyD'] || keys['ArrowRight']) playerBattle.x += speed;
    
    playerBattle.x = Math.max(8, Math.min(186, playerBattle.x));
    playerBattle.y = Math.max(8, Math.min(126, playerBattle.y));
    
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      
      if (b.type === 'ghost') {
        if (b.phase === 'grow') {
          b.size = Math.min(b.maxSize, b.size + 0.3);
          if (b.size >= b.maxSize) {
            b.phase = 'wait';
            b.timer = 500;
          }
        } else if (b.phase === 'wait') {
          b.timer -= dt;
          if (b.timer <= 0) {
            b.phase = 'shrink';
          }
        } else if (b.phase === 'shrink') {
          b.size -= 0.5;
          if (b.size <= 0) {
            bullets.splice(i, 1);
            continue;
          }
        }
      } else {
        b.x += b.vx;
        b.y += b.vy;
        
        if (b.wave) {
          b.x = b.startX + Math.sin(b.y * b.waveFreq) * b.waveAmp;
        }
      }
      
      if (b.x < -50 || b.x > 250 || b.y < -50 || b.y > 190) {
        bullets.splice(i, 1);
        continue;
      }
      
      if (playerBattle.invincible <= 0) {
        let hit = false;
        
        if (b.type === 'rect') {
          hit = rectCollide(
            { x: playerBattle.x - 8, y: playerBattle.y - 8, w: 16, h: 16 },
            { x: b.x - b.width/2, y: b.y - b.height/2, w: b.width, h: b.height }
          );
        } else {
          const dist = Math.hypot(playerBattle.x - b.x, playerBattle.y - b.y);
          hit = dist < (playerBattle.width/2 + b.size/2 - 2);
        }
        
        if (hit && b.type === 'dive' && playerBattle.diving) {
          hit = false;
        }
        
        if (hit) {
          const damage = Math.max(1, currentEnemy.atk - player.def);
          player.hp -= damage;
          playerBattle.invincible = 1000;
          playSound('hurt');
          screenShake = 8;
          
          if (player.hp <= 0) {
            player.hp = 0;
            gameOver();
            return;
          }
          
          updateBattleUI();
        }
      }
    }
    
    if (playerBattle.invincible > 0) {
      playerBattle.invincible -= dt;
    }
  }
}

function rectCollide(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function changeArea(areaIndex, spawnX, spawnY) {
  currentArea = areaIndex;
  player.x = spawnX;
  player.y = spawnY;
  
  const area = areas[currentArea];
  document.getElementById('location').textContent = area.name;
  playMusic(area.music);
  
  saveGame();
}

function gameOver() {
  inBattle = false;
  document.getElementById('battle-ui').classList.remove('active');
  document.getElementById('game-over').style.display = 'flex';
  stopMusic();
  playSound('hurt');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
  const area = areas[currentArea];
  
  ctx.save();
  if (screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * screenShake,
      (Math.random() - 0.5) * screenShake
    );
  }
  
  ctx.fillStyle = area.bg;
  ctx.fillRect(0, 0, 640, 480);
  
  if (gameState === 'playing' && !inBattle) {
    const camX = Math.max(0, Math.min(area.width - 640, player.x - 320));
    const camY = Math.max(0, Math.min(area.height - 480, player.y - 240));
    
    ctx.save();
    ctx.translate(-camX, -camY);
    
    drawAreaBackground(area);
    
    ctx.fillStyle = '#333';
    for (const obs of area.obstacles) {
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.fillStyle = '#444';
      ctx.fillRect(obs.x + 2, obs.y + 2, obs.w - 4, 4);
      ctx.fillStyle = '#333';
    }
    
    for (const puzzleArea of area.puzzles || []) {
      const puzzle = puzzles[puzzleArea.id];
      if (!puzzle) continue;
      
      if (!puzzle.solved) {
        ctx.fillStyle = '#ff0';
        ctx.globalAlpha = 0.3;
        ctx.fillRect(puzzleArea.x, puzzleArea.y, puzzleArea.w, puzzleArea.h);
        ctx.globalAlpha = 1;
        
        if (puzzle.type === "tile_puzzle") {
          for (const tile of puzzle.tiles) {
            ctx.fillStyle = tile.color;
            ctx.globalAlpha = tile.stepped ? 1 : 0.5;
            ctx.fillRect(tile.x - 15, tile.y - 15, 30, 30);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(tile.x - 15, tile.y - 15, 30, 30);
          }
        } else if (puzzle.type === "switch_puzzle") {
          for (const sw of puzzle.switches) {
            ctx.fillStyle = sw.pressed ? '#0f0' : '#f00';
            ctx.fillRect(sw.x - 10, sw.y - 10, 20, 20);
            ctx.fillStyle = '#000';
            ctx.fillText(sw.correct ? 'âœ“' : 'âœ—', sw.x - 3, sw.y + 4);
          }
        } else if (puzzle.type === "current_puzzle") {
          for (const current of puzzle.currents) {
            ctx.fillStyle = current.active ? '#0ff' : '#00a';
            ctx.globalAlpha = 0.6;
            ctx.fillRect(current.x, current.y, current.w, current.h);
            ctx.globalAlpha = 1;
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            let arrow = 'â†’';
            if (current.direction === 'left') arrow = 'â†';
            else if (current.direction === 'up') arrow = 'â†‘';
            else if (current.direction === 'down') arrow = 'â†“';
            ctx.fillText(arrow, current.x + current.w/2, current.y + current.h/2 + 4);
          }
        } else if (puzzle.type === "block_puzzle") {
          for (const block of puzzle.blocks) {
            ctx.fillStyle = block.movable ? '#8B4513' : '#696969';
            ctx.fillRect(block.x - block.w/2, block.y - block.h/2, block.w, block.h);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(block.x - block.w/2, block.y - block.h/2, block.w, block.h);
          }
          
          const target = puzzle.targetArea;
          ctx.fillStyle = '#0f0';
          ctx.globalAlpha = 0.3;
          ctx.fillRect(target.x - target.w/2, target.y - target.h/2, target.w, target.h);
          ctx.globalAlpha = 1;
        }
      }
    }
    
    for (const item of area.items) {
      if (!itemsCollected.includes(item.id)) {
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(item.x, item.y, 8 + Math.sin(gameTime * 5) * 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('?', item.x, item.y + 4);
      }
    }
    
    for (const npc of area.npcs) {
      if (npc.boss && bossesDefeated.includes(npc.boss)) continue;
      
      ctx.fillStyle = npc.color;
      ctx.fillRect(npc.x - 15, npc.y - 15, 30, 30);
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(npc.name, npc.x, npc.y - 20);
    }
    
    for (const exit of area.exits) {
      if (exit.requireBoss && !bossesDefeated.includes(exit.requireBoss)) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
      } else if (exit.requirePuzzle) {
        const puzzle = puzzles[exit.requirePuzzle];
        if (puzzle && !puzzle.solved) {
          ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
        } else {
          ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        }
      } else {
        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
      }
      ctx.fillRect(exit.x, exit.y, exit.w, exit.h);
    }
    
    drawPlayer();
    
    drawSheldon(player.x - 25, player.y + 10);
    
    ctx.restore();
  }
  
  if (inBattle) {
    renderBattle();
  }
  
  ctx.restore();
  
  if (gameState === 'playing') {
    document.getElementById('hud').innerHTML = `
      LV: ${player.lv} | HP: ${player.hp}/${player.maxHp} | G: ${player.gold}<br>
      ${player.name} | Kills: ${player.kills} | Spares: ${player.spares}
    `;
  }
}

function drawAreaBackground(area) {
  const time = gameTime;
  
  if (currentArea === 0) {
    ctx.fillStyle = 'rgba(100, 150, 200, 0.3)';
    for (let i = 0; i < 20; i++) {
      const x = (i * 97 + time * 20) % area.width;
      const y = (i * 73 + Math.sin(time + i) * 30) % area.height;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  } else if (currentArea === 1) {
    ctx.fillStyle = 'rgba(255, 100, 150, 0.2)';
    for (let i = 0; i < 15; i++) {
      const x = (i * 127) % area.width;
      const y = (i * 83) % area.height;
      ctx.beginPath();
      ctx.arc(x, y, 20 + Math.sin(time * 2 + i) * 5, 0, Math.PI * 2);
      ctx.fill();
    }
  } else if (currentArea === 2) {
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 10; i++) {
      ctx.beginPath();
      const y = (i * 50 + time * 100) % area.height;
      ctx.moveTo(0, y);
      for (let x = 0; x < area.width; x += 50) {
        ctx.lineTo(x, y + Math.sin(x * 0.02 + time * 3) * 10);
      }
      ctx.stroke();
    }
  } else if (currentArea === 3) {
    ctx.strokeStyle = 'rgba(139, 90, 43, 0.3)';
    ctx.lineWidth = 3;
    for (let i = 0; i < 20; i++) {
      ctx.beginPath();
      ctx.moveTo(i * 50, 0);
      ctx.lineTo(i * 50, area.height);
      ctx.stroke();
    }
  }
}

function drawPlayer() {
  const px = player.x;
  const py = player.y;
  
  ctx.fillStyle = '#5D4037';
  ctx.beginPath();
  ctx.ellipse(px, py + 22, 5, 18, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#4E342E';
  ctx.beginPath();
  ctx.ellipse(px, py + 28, 4, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#5D4037';
  ctx.beginPath();
  ctx.ellipse(px - 10, py + 8, 5, 4, -0.3, 0, Math.PI * 2);
  ctx.ellipse(px + 10, py + 8, 5, 4, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#8D6E63';
  ctx.beginPath();
  ctx.ellipse(px, py, 14, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#D7CCC8';
  ctx.beginPath();
  ctx.ellipse(px, py + 2, 8, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#5D4037';
  ctx.beginPath();
  ctx.ellipse(px - 8, py + 2, 4, 3, -0.4, 0, Math.PI * 2);
  ctx.ellipse(px + 8, py + 2, 4, 3, 0.4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#8D6E63';
  ctx.beginPath();
  ctx.arc(px, py - 14, 11, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#6D4C41';
  ctx.beginPath();
  ctx.arc(px - 8, py - 22, 4, 0, Math.PI * 2);
  ctx.arc(px + 8, py - 22, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#FFCCBC';
  ctx.beginPath();
  ctx.arc(px - 8, py - 22, 2, 0, Math.PI * 2);
  ctx.arc(px + 8, py - 22, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#D7CCC8';
  ctx.beginPath();
  ctx.ellipse(px, py - 11, 7, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(px - 5, py - 16, 2.5, 0, Math.PI * 2);
  ctx.arc(px + 5, py - 16, 2.5, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(px - 4, py - 17, 1, 0, Math.PI * 2);
  ctx.arc(px + 6, py - 17, 1, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.ellipse(px, py - 10, 3, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#4E342E';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(px - 4, py - 10);
  ctx.lineTo(px - 14, py - 12);
  ctx.moveTo(px - 4, py - 9);
  ctx.lineTo(px - 14, py - 8);
  ctx.moveTo(px - 4, py - 8);
  ctx.lineTo(px - 13, py - 5);
  ctx.moveTo(px + 4, py - 10);
  ctx.lineTo(px + 14, py - 12);
  ctx.moveTo(px + 4, py - 9);
  ctx.lineTo(px + 14, py - 8);
  ctx.moveTo(px + 4, py - 8);
  ctx.lineTo(px + 13, py - 5);
  ctx.stroke();
  
  ctx.strokeStyle = '#5D4037';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(px - 2, py - 7, 2, 0.1, Math.PI - 0.1);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(px + 2, py - 7, 2, 0.1, Math.PI - 0.1);
  ctx.stroke();
}

function drawSheldon(x, y) {
  ctx.fillStyle = sheldonMood.includes('genocide') ? '#666' : '#FF69B4';
  ctx.beginPath();
  ctx.ellipse(x, y, 8, 5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = sheldonMood.includes('genocide') ? '#444' : '#FF1493';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(x - 8, y + 2, 5, 0, Math.PI);
  ctx.stroke();
  
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(x + 5, y - 2, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = sheldonMood.includes('genocide') ? '#555' : '#FF69B4';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x + 7, y - 3);
  ctx.lineTo(x + 12, y - 8);
  ctx.moveTo(x + 7, y - 1);
  ctx.lineTo(x + 13, y - 4);
  ctx.stroke();
}

function renderBattle() {
  ctx.fillStyle = currentEnemy.color;
  ctx.fillRect(280, 60, 80, 80);
  
  ctx.fillStyle = '#fff';
  ctx.font = '14px monospace';
  ctx.textAlign = 'center';
  
  if (currentEnemy.isBoss) {
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.moveTo(300, 50);
    ctx.lineTo(310, 60);
    ctx.lineTo(320, 45);
    ctx.lineTo(330, 60);
    ctx.lineTo(340, 50);
    ctx.lineTo(340, 65);
    ctx.lineTo(300, 65);
    ctx.closePath();
    ctx.fill();
  }
  
  battleCtx.fillStyle = '#000';
  battleCtx.fillRect(0, 0, 194, 134);
  
  for (const b of bullets) {
    if (b.type === 'dive') {
      battleCtx.fillStyle = '#00ffff';
    } else if (b.type === 'ghost') {
      battleCtx.fillStyle = `rgba(139, 134, 130, ${b.size / b.maxSize})`;
    } else {
      battleCtx.fillStyle = b.color || '#fff';
    }
    
    if (b.type === 'rect') {
      battleCtx.fillRect(b.x - b.width/2, b.y - b.height/2, b.width, b.height);
    } else {
      battleCtx.beginPath();
      battleCtx.arc(b.x, b.y, b.size / 2, 0, Math.PI * 2);
      battleCtx.fill();
    }
  }
  
  if (battleState === 'dodge') {
    const px = playerBattle.x;
    const py = playerBattle.y;
    
    if (playerBattle.invincible > 0 && Math.floor(playerBattle.invincible / 100) % 2 === 0) {
      battleCtx.globalAlpha = 0.5;
    }
    
    battleCtx.fillStyle = playerBattle.diving ? '#00ffff' : '#ff0000';
    
    battleCtx.beginPath();
    battleCtx.moveTo(px, py + 4);
    battleCtx.bezierCurveTo(px - 8, py - 4, px - 8, py - 10, px, py - 6);
    battleCtx.bezierCurveTo(px + 8, py - 10, px + 8, py - 4, px, py + 4);
    battleCtx.fill();
    
    battleCtx.globalAlpha = 1;
    
    if (playerBattle.diving) {
      battleCtx.strokeStyle = '#00ffff';
      battleCtx.lineWidth = 2;
      battleCtx.beginPath();
      battleCtx.arc(px, py, 12, 0, Math.PI * 2);
      battleCtx.stroke();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastTime = performance.now();

function gameLoop(now) {
  const dt = now - lastTime;
  lastTime = now;
  
  update(dt);
  render();
  
  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function init() {
  if (hasSaveFile()) {
    document.getElementById('continue-btn').style.display = 'block';
  }
  
  document.getElementById('new-game-btn').onclick = () => {
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('name-screen').style.display = 'flex';
    gameState = 'naming';
    document.getElementById('name-input').focus();
    initAudio();
  };
  
  document.getElementById('continue-btn').onclick = () => {
    if (loadGame()) {
      document.getElementById('menu-screen').style.display = 'none';
      gameState = 'playing';
      changeArea(currentArea, player.x, player.y);
      initAudio();
    }
  };
  
  const nameInput = document.getElementById('name-input');
  const easterDisplay = document.getElementById('name-easter');
  
  nameInput.oninput = () => {
    const name = nameInput.value.toLowerCase().trim();
    if (nameEasterEggs[name]) {
      easterDisplay.textContent = nameEasterEggs[name].msg;
      nameSpecial = nameEasterEggs[name].special;
    } else {
      easterDisplay.textContent = '';
      nameSpecial = null;
    }
  };
  
  nameInput.onblur = () => {
    keys = {};
  };
  
  document.getElementById('confirm-name-btn').onclick = () => {
    let name = nameInput.value.trim();
    if (name.length === 0) name = 'Otto';
    if (name.length > 12) name = name.substring(0, 12);
    
    if (nameSpecial === 'empty') return;
    if (nameSpecial === 'sheldon') {
      alert("Hey! That's MY name!");
      return;
    }
    
    player.name = name;
    deleteSave();
    
    document.getElementById('name-screen').style.display = 'none';
    gameState = 'playing';
    changeArea(0, 300, 500);
    
    if (nameSpecial === 'temmie') {
      showSheldonComment('hOI!!! welcom 2... da UNDERGROUND!!!');
    } else if (nameSpecial === 'sans') {
      showSheldonComment('...');
    } else if (nameSpecial === 'dark') {
      sheldonMood = 'warning1';
    } else if (nameSpecial === 'josh') {
      showSheldonComment('Oh cool, you know the creator! VIP treatment!');
    } else if (nameSpecial === 'mercy') {
      showSheldonComment('I have a good feeling about you!');
    }
    
    saveGame();
  };
  
  document.getElementById('back-name-btn').onclick = () => {
    document.getElementById('name-screen').style.display = 'none';
    document.getElementById('menu-screen').style.display = 'flex';
    gameState = 'menu';
  };
  
  document.querySelectorAll('#battle-menu button').forEach((btn, i) => {
    btn.onclick = () => {
      if (battleState === 'menu') {
        battleMenuIndex = i;
        updateMenuSelection();
        handleKeyPress('KeyZ');
      }
    };
  });
  
  document.getElementById('puzzle-ok-btn').onclick = () => {
    hidePuzzlePrompt();
  };
  
  document.getElementById('retry-btn').onclick = () => {
    document.getElementById('game-over').style.display = 'none';
    if (loadGame()) {
      gameState = 'playing';
      changeArea(currentArea, player.x, player.y);
    } else {
      location.reload();
    }
  };
  
  document.getElementById('ending-btn').onclick = () => {
    location.reload();
  };
  
  requestAnimationFrame(gameLoop);
}

init();
</script></body></html>
